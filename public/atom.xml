<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>nihao&#39; Blog</title>
  
  
  <link href="https://xuhaodong1.github.io/atom.xml" rel="self"/>
  
  <link href="https://xuhaodong1.github.io/"/>
  <updated>2023-07-25T09:01:53.112Z</updated>
  <id>https://xuhaodong1.github.io/</id>
  
  <author>
    <name>nihao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS中的内存管理｜AutoreleasePool</title>
    <link href="https://xuhaodong1.github.io/2023/07/25/iOS%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BD%9CAutoReleasePool/"/>
    <id>https://xuhaodong1.github.io/2023/07/25/iOS%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BD%9CAutoReleasePool/</id>
    <published>2023-07-25T01:49:00.000Z</published>
    <updated>2023-07-25T09:01:53.112Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>在 ARC 中，使用 AutoreleasePool 非常简单，只需形如以下方式调用即可，编译器会将块中的对象插入类似如 <code>[obj autorelease];</code> 一样的代码，在超出 AutoreleasePool 块作用域后会自动调用对象的 <code>release</code> 方法，这能延迟对象的释放。但一般来说，并不需要显式使用 <code>@autoreleasepool{ }</code>，这是因为在主线程 RunLoop 的每个周期中都会自动进行自动释放池的创建和销毁。</p><span id="more"></span><pre><code class="objc">@autoreleasepool {        }</code></pre><h2 id="什么对象会纳入到-AutoreleasePool-中？"><a href="#什么对象会纳入到-AutoreleasePool-中？" class="headerlink" title="什么对象会纳入到 AutoreleasePool 中？"></a>什么对象会纳入到 AutoreleasePool 中？</h2><p>除了显式加入 <code>__autoreleasing</code> 所有权修饰对象外，还有些对象会直接被隐式纳入 AutoReleasePool 管理。</p><ul><li>非自己生成并持有的对象</li></ul><p>编译器会检查方法名是否以 <code>alloc</code>、<code>new</code>、<code>copy</code>、<code>mutableCopy</code> 开始，如果不是则自动将其返回值注册到 AutoreleasePool 中。ARC 通过命名约定将内存管理标准化，本来 ARC 也可以直接舍弃 autorelease 这个概念，并且规定，所有从方法中返回的对象其引用计数比预期的多 1，但这样做就破坏了向后兼容性（backward compatibility），无法与不使用 ARC 的代码兼容。</p><p>不过利用 <code>clang attribute</code> ，如 <code>- (id)allocObject __attribute__((objc_method_family(none)))</code>，会将<code>allocObject</code> 这个方法当做普通方法返回对象看待。</p><p>在普通方法返回对象后，可能会将对象 <code>retain</code> 一次以进行强持有。例如以下的代码会被翻译为：</p><pre><code class="objc">EOCPerson _myPerson = [EOCPerson personWithName: @"Bob Smith"]; // 会调用 `autorelease`// 被翻译为EOCPerson *tmp = [EOCPerson personWithName: @"Bob Smith"];_myPerson = [tmp retain];</code></pre><p>其中 <code>autorelease</code> 和 <code>retain</code> 结对出现，是多余的，为了提升性能可以将其删除。于是编译器在被调用方采用 <code>objc_retainAutoreleaseReturnValue</code> 方法取代 <code>autorelease</code> ，会检查即将执行的那段代码是否会执行 <code>retain</code> 操作，若有则会在线程局部存储（TLS，Thread Local Storage）中存储这个对象，不执行 <code>autorelease </code> 操作；在调用方采用 <code>objc_retainAutoreleasedReturnValue</code> 方法取代 <code>retain</code> ，会检测 TLS 是否存了这个对象，若有则直接返回这个对象，不进行 <code>retain</code> 操作。</p><ul><li>id 的指针或对象的指针</li></ul><p>id 的指针（<code>id **</code>）和对象的指针（<code>NSError **</code>），如果没有显式指定，会自动加上关键字 <code>__autoreleasing</code>，注册到 AutoreleasePool 中。</p><ul><li>关于 <code>__weak1</code> 修饰的对象</li></ul><p>在 LLVM 8.0 之前的编译器，关键字 <code>__weak</code> 修饰的对象，会自动注册到 AutoreleasePool 中；在 LLVM 8.0 以及之后的编译器，则会直接调用 <code>release</code> 方法。</p><h2 id="什么时候显式使用-autoreleasepool？"><a href="#什么时候显式使用-autoreleasepool？" class="headerlink" title="什么时候显式使用 @autoreleasepool？"></a>什么时候显式使用 @autoreleasepool？</h2><ul><li>CLI（Command-line interface）程序</li></ul><p>在 Cocoa 框架中由于有 RunLoop 机制的原因，每个周期都会进行自动释放池的创建与释放，但在 CLI 中意味着不会定期清理内存，因此需要更多关注。</p><ul><li>循环中使生成大量局部变量</li></ul><p>再循环过程中产生了大量的局部变量，会导致内存峰值过高，因此手动加入 <code>@autoreleasepool</code> 可以降低内存使用峰值。</p><p>虽然只有 Autorelease 对象（也即上文提到的哪些对象会纳入 AutoreleasePool 管理）会纳入AutoreleasePool 管理，但这可以利用块机制，让编译器将在块末尾自动插入 <code>release</code> 代码。</p><pre><code class="swift">func loadBigData() {    if let path = NSBundle.mainBundle().pathForResource("big", ofType: "jpg") {        for i in 1...10000 {            autoreleasepool {                let data = NSData.dataWithContentsOfFile(path, options: nil, error: nil)                let person = Person("nihao") //也会释放                NSThread.sleepForTimeInterval(0.5)            }        }    }}</code></pre><ul><li>常驻线程</li></ul><p>主线程的 RunLoop 会在每个周期进行自动释放池的创建与释放，子线程则不会，同时子线程也不一定会有 RunLoop。但只要是 Autorelease 对象，就会自动纳入 AutoreleasePool 管理，每个线程都会自动创建并管理自己的自动释放池，等到线程销毁的时候释放。但常驻线程中的对象因线程无法销毁迟迟得不到释放，这就需要手动添加 AutoreleasePool：</p><pre><code class="swift">class KeepAliveThreadManager {    private init() {}    static let shared = KeepAliveThreadManager()    private(set) var thread: Thread?    /// 开启常驻线程    public func start() {        if thread != nil, thread!.isExecuting {            return        }        thread = Thread {            autoreleasepool {                let currentRunLoop = RunLoop.current                // 如果想要加对该RunLoop的状态观察，需要在获取后添加，而不是等到启动之后再添加，                currentRunLoop.add(Port(), forMode: .common)                currentRunLoop.run()            }        }        thread?.start()    }    /// 关闭常驻线程    public func end() {        thread?.cancel()        thread = nil    }}class Test: NSObject {    func test() {        if let thread = KeepAliveThreadManager.shared.thread {            perform(#selector(task), on: thread, with: nil, waitUntilDone: false)        }    }    @objc    func task() {        /// 在任务外加一层 autoreleasepool        autoreleasepool {        }    }}</code></pre><h2 id="与-RunLoop-的关系"><a href="#与-RunLoop-的关系" class="headerlink" title="与 RunLoop 的关系"></a>与 RunLoop 的关系</h2><p>主线程在 RunLoop 中注册了两个 Observer，其回调都是 <code>_wrapRunLoopWithAutoreleasePoolHandler</code>。</p><ul><li>第一个 Observer 监测 <code>Entry</code> 事件（即将进入 RunLoop）</li></ul><p>回调内部会调用 <code>_objc_autoreleasePoolPush</code> 创建自动释放池，其 order = -214748364，优先级最高，保证创建自动释放池在其他所有回调之前。</p><ul><li>第二个 Observer 监测 <code>BeforeWaiting</code> 及 <code>Exit</code> 事件</li></ul><p><code>BeforeWaiting</code> 时调用 <code>_objc_autoreleasePoolPop()</code> 和 <code>_objc_autoreleasePoolPush()</code> 释放旧的自动释放池并创建新的自动释放池。</p><p><code>Exit</code> 时调用 <code>_objc_autoreleasePoolPop</code> 来释放自动释放池，其 order = 2147483647，优先级最低，保证其其它回调都在释放自动释放池之前。</p><h2 id="AutoReleasePool-源码"><a href="#AutoReleasePool-源码" class="headerlink" title="AutoReleasePool 源码"></a>AutoReleasePool 源码</h2><p>形如 <code>_objc_autoreleasePoolPush</code> 、 <code>_objc_autoreleasePoolPush</code> 和 <code>objc_autorelease</code> 其内部都是调用 <code>AutoreleasePoolPage</code> 的相关静态方法。因此其源码主要是对 <code>AutoreleasePoolPage</code> 的探索。</p><p>以下参考的源码为 objc4-838。</p><pre><code class="c++">void *objc_autoreleasePoolPush(void) {    return AutoreleasePoolPage::push();} void objc_autoreleasePoolPop(void *ctxt) {    AutoreleasePoolPage::pop(ctxt);}__attribute__((noinline,used))id objc_object::rootAutorelease2(){    ASSERT(!isTaggedPointer());    return AutoreleasePoolPage::autorelease((id)this);}</code></pre><h3 id="AutoreleasePoolPage-的数据结构"><a href="#AutoreleasePoolPage-的数据结构" class="headerlink" title="AutoreleasePoolPage 的数据结构"></a>AutoreleasePoolPage 的数据结构</h3><p><code>AutoreleasePoolPage</code> 继承自 <code>AutoreleasePoolPageData</code>，<code>AutoreleasePoolPageData</code> 存储了自动释放池实例对象的信息，而 <code>AutoreleasePoolPage</code> 里则存储了全局所有的自动释放池的所需信息，因此其属性类型也都是 <code>static const</code>。</p><pre><code class="c++">struct AutoreleasePoolPageData{#if SUPPORT_AUTORELEASEPOOL_DEDUP_PTRS    // 用来优化同一对象多次加入 AutoreleasePoolPage，只需记录其地址与数量，无需重复递增，节省空间    struct AutoreleasePoolEntry {        uintptr_t ptr: 48;        uintptr_t count: 16;        static const uintptr_t maxCount = 65535; // 2^16 - 1    };#endif  // 对当前 AutoreleasePool 完整性校验    magic_t const magic;  // 指向下一个即将产生的 autorelease 对象的位置    __unsafe_unretained id *next;  // 关联的线程    pthread_t const thread;  // 指向父节点    AutoreleasePoolPage * const parent;  // 指向字节点    AutoreleasePoolPage *child;  // 链表的深度    uint32_t const depth;  // 水位线(DEBUG 使用，用作判断上次和这次的对象增加数量)    uint32_t hiwat;};</code></pre><p>从 <code>next</code>、<code>parent</code>、<code>child</code> 的结构来看，构成了以栈作为节点的双向链表，每个 <code>AutorleasePoolPage</code> 的大小为 4096 个字节。</p><p><img src="/images/blog/image-20230724164816710.png" alt="image-20230724164816710"></p><p>值的注意的是，引入了 <code>AutoreleasePoolEntry</code> 结构，用作将同一对象多次进行 <code>autorelease</code> 操作时的优化，这时不会将 <code>next</code> 递增，而是将 <code>AutoreleasePoolEntry</code> 中 <code>count</code> 递增，得以优化内存空间。这里将 <code>ptr</code> 和 <code>count</code> 指定存储大小，其总大小为 64 字节，与 <code>id</code> 类型指针大小相同，使得 <code>AutoreleasePoolEntry</code> 和 普通的 <code>id</code> 类型可以互操作。</p><pre><code class="c++">class AutoreleasePoolPage : private AutoreleasePoolPageData{public:  // 每个 Page 的大小，为 4096 字节(虚拟内存一页的大小)    static size_t const SIZE = PAGE_MIN_SIZE;    private:  // 关于 AutoreleasePool 的 Key，用来查找存储在 TLS 中线程的 HotPage    static pthread_key_t const key = AUTORELEASE_POOL_KEY;  // 释放对象后用 0xA3A3A3A3 占位    static uint8_t const SCRIBBLE = 0xA3;  // 存储对象个数    static size_t const COUNT = SIZE / sizeof(id);  // 最大错误数量(DEBUG 使用)  static size_t const MAX_FAULTS = 2;}</code></pre><p>关于 <code>AutoreleasePoolPage</code> 的静态属性，其中比较重要的：</p><ul><li><code>size</code> 固定为 <code>4096</code>，刚好为虚拟内存大小的一页。</li><li><code>key</code> 为 <code>43</code>，用作线程局部存储的 <code>Key</code>，存储的是线程所属的 <code>hotPage</code>，隔离区分其他线程的 <code>AutoreleasePoolPage</code>。</li><li><code>SCRIBBLE</code> 为 <code>0xA3A3A3A3</code>，在用作占位释放掉的 <code>next</code> 指针，标识为未初始化的地址。</li></ul><h3 id="AutoreleasePoolPage-push"><a href="#AutoreleasePoolPage-push" class="headerlink" title="AutoreleasePoolPage::push()"></a>AutoreleasePoolPage::push()</h3><p><code>AutoreleasePoolPage::push() </code> 创建一个自动释放池，实际上是插入一个 <code>POOL_BOUNDARY</code> （哨兵对象，指向 <code>nil</code>）用来表示不同的自动释放池，去除掉 <code>DEBUG</code> 调试和一些边界条件，其主要逻辑集中在 <code>autoreleaseFast</code> 方法中，根据 <code>hotPage</code> 的状态分为三种情况：</p><p>关于 <code>hotPage</code>，其存储在 TLS 中，表示当前正活跃的 <code>Page</code>；与之相对应是 <code>coldPage</code>，指向的是双向链表的头节点。</p><pre><code class="c++">// 此处的 obj 为 POOL_BOUNDARYstatic inline id *autoreleaseFast(id obj) {    AutoreleasePoolPage *page = hotPage();    if (page &amp;&amp; !page-&gt;full()) {        return page-&gt;add(obj);    } else if (page) {        return autoreleaseFullPage(obj, page);    } else {        return autoreleaseNoPage(obj);    }}</code></pre><ul><li>存在 <code>hotPage</code> 并且 <code>hotPage</code> 未满</li></ul><p>这是直接调用 <code>hotPage</code> 的 <code>add</code> 实例方法，根据宏定义，判断是否利用 <code>AutoreleasePoolEntry</code> 类型优化同一对象的多次 <code>autorelease</code>，否则直接加入，<code>next</code> 指向下一个将要加入 <code>AutoreleasePoolPage</code> 的地址。</p><ul><li>存在 <code>hotPage</code> 并且 <code>hotPage</code> 已满</li></ul><p>从 <code>hotPage</code> ，遍历找一个未满的子节点，若没有则创建一个 <code>AutoreleasePoolPage</code> ，随后将找到或生成的 <code>page</code> 置为 <code>hotPage</code> （利用 TLS 机制），并将对象 <code>add</code> 到 <code>hotPage</code> 中。</p><ul><li>不存在 <code>hotPage</code></li></ul><p>创建一个 <code>AutoreleasePoolPage</code> ，将其设置为 <code>hotPage</code>，并将对象加入到 <code>hotPage</code> 中。</p><h3 id="AutoreleasePoolPage-pop-ctxt"><a href="#AutoreleasePoolPage-pop-ctxt" class="headerlink" title="AutoreleasePoolPage::pop(ctxt)"></a>AutoreleasePoolPage::pop(ctxt)</h3><p><code>pop</code> 方法需要传入参数，在 <code>_objc_autoreleasePoolPush</code> 中是传入 <code>push</code> 方法返回的参数，<code>push</code> 返回的是存储的哨兵对象的地址，因此传入的也是哨兵对象的地址。</p><p>不过该方法也可能在其他地方调用，如果是哨兵对象的地址会销毁整个以哨兵对象开始的单个自动释放池，还有可能销毁整个自动释放池，其方法主要逻辑如下：</p><pre><code class="c++">static inline voidpop(void *token){    AutoreleasePoolPage *page;    id *stop;    if (token == (void*)EMPTY_POOL_PLACEHOLDER) {        page = hotPage();        if (!page) {            // 如果整个自动释放池为空，仅有占位符，以 nil 填充            return setHotPage(nil);        }        // 从头节点开始，移除自动释放池中的所有内容        page = coldPage();        token = page-&gt;begin();    } else {        page = pageForPointer(token);    }    stop = (id *)token;    return popPage&lt;false&gt;(token, page, stop);}</code></pre><p>如何通过到 <code>token</code>（也即传入的哨兵对象的地址） 查找到所对应的 <code>AutoreleasePoolPage</code> ，在 <code>pageForPointer</code> 方法中。</p><p>这里有个前置条件，<code>AutoreleasePoolPage</code> 会通过 <code>malloc_zone_memalign</code> 方式分配内存，因此每个 <code>AutoreleasePoolPage</code> 的地址都是 <code>SIZE</code>（4096）的倍数，也就是地址会进行对齐，在与 <code>SIZE</code> 进行取余操作后，得到相对于 <code>token</code> 所在的 <code>AutoreleasePoolPage</code> 的偏移，相减则就能得到其首地址。</p><pre><code class="c++">static AutoreleasePoolPage *pageForPointer(uintptr_t p) {    AutoreleasePoolPage *result;    uintptr_t offset = p % SIZE;    ASSERT(offset &gt;= sizeof(AutoreleasePoolPage));    result = (AutoreleasePoolPage *)(p - offset);    result-&gt;fastcheck();    return result;}</code></pre><p>在 <code>popPage</code> 方法中，从 <code>hotPage</code> 开始，一直进行出栈操作，也即会 <code>objc_release(obj);</code>，直到满足栈首的地址与 <code>stop</code> 的地址一致，之后会调用 <code>child</code> / <code>child-&gt; child</code> 的 <code>kill</code> 方法，将所有的子节点销毁。</p><p>有意思的是，会根据子节点的状态（子节点中已存储大小小于总大小的一半）进行区分，更有意思的是，在进行 <code>releaseUntil</code> 方法时，会将每一个子节点清空，里面也会判断 <code>ASSERT(page-&gt;empty());</code>，因此只会调用 <code>page-&gt;child-&gt;kill();</code>。</p><p>不过这里提到一个概念，迟滞现象（hysteresis），wiki 是这样解释的：</p><blockquote><p>一系统经过某一输入路径之运作后，即使换回最初的状态时同样的输入值，状态也不能回到其初始。</p></blockquote><p>推测是虽然需要将所有子节点清空，但是系统不同以往了，可能后续需要重新创建子节点，这里先不清空，为后续使用提高效率。</p><pre><code class="c++">template&lt;bool allowDebug&gt;static voidpopPage(void *token, AutoreleasePoolPage *page, id *stop){    page-&gt;releaseUntil(stop);    if (page-&gt;child) {        // hysteresis: keep one empty child if page is more than half full        if (page-&gt;lessThanHalfFull()) {            page-&gt;child-&gt;kill();        }        else if (page-&gt;child-&gt;child) {            page-&gt;child-&gt;child-&gt;kill();        }    }}</code></pre><h3 id="objc-autorelease"><a href="#objc-autorelease" class="headerlink" title="objc_autorelease"></a>objc_autorelease</h3><p>去除掉一些优化条件，如是否是 <code>taggedPointer</code> 指针，是否采用 TLS 优化 <code>autorelease</code> 步骤 （上文提到），是否是类对象等。</p><p>一般最终会指向 <code>AutoreleasePoolPage::autorelease((id)this);</code> ，这与 <code>AutoreleasePoolPage::push()</code> 的分析情况一致。</p><pre><code class="c++">static inline id autorelease(id obj){    ASSERT(!_objc_isTaggedPointerOrNil(obj));    id *dest __unused = autoreleaseFast(obj);#if SUPPORT_AUTORELEASEPOOL_DEDUP_PTRS    ASSERT(!dest  ||  dest == EMPTY_POOL_PLACEHOLDER  ||  (id)((AutoreleasePoolEntry *)dest)-&gt;ptr == obj);#else    ASSERT(!dest  ||  dest == EMPTY_POOL_PLACEHOLDER  ||  *dest == obj);#endif    return obj;}</code></pre><h2 id="🔗"><a href="#🔗" class="headerlink" title="🔗"></a>🔗</h2><p>[1] <a href="https://stackoverflow.com/questions/9086913/why-is-autoreleasepool-still-needed-with-arc#:~:text=(%2D1)%20%40autoreleasepool%20Forces%20process,footprint%20will%20be%20constantly%20increasing">Why is @autoreleasepool still needed with arc</a></p><p>[2] <a href="https://book.douban.com/subject/24720270/">Objective-C 高级编程 iOS与OS X多线程和内存管理</a></p><p>[3] <a href="https://mp.weixin.qq.com/s/Z3MWUxR2SLtmzFZ3e5WzYQ">AutoreleasePool</a></p><p>[4] <a href="https://book.douban.com/subject/25829244/">Effective Objective-C 2.0 编写高质量iOS与OS X代码的52个有效方法</a></p><p>[5] <a href="https://stackoverflow.com/questions/40993809/why-weak-object-will-be-added-to-autorelease-pool">Why __weak object will be added to autorelease pool?</a></p><p>[6] <a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/">黑幕后的Autorelease</a></p><p>[7] <a href="https://zhuanlan.zhihu.com/p/323200445">iOS AutoreleasePool</a></p><p>[8] <a href="https://github.com/xuhaodong1/objc4_838_source_code">nihao_objc4_838</a></p><p>[9] <a href="https://zh.wikipedia.org/zh-sg/%E9%81%B2%E6%BB%AF%E7%8F%BE%E8%B1%A1">迟滞现象</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;基本使用&quot;&gt;&lt;a href=&quot;#基本使用&quot; class=&quot;headerlink&quot; title=&quot;基本使用&quot;&gt;&lt;/a&gt;基本使用&lt;/h2&gt;&lt;p&gt;在 ARC 中，使用 AutoreleasePool 非常简单，只需形如以下方式调用即可，编译器会将块中的对象插入类似如 &lt;code&gt;[obj autorelease];&lt;/code&gt; 一样的代码，在超出 AutoreleasePool 块作用域后会自动调用对象的 &lt;code&gt;release&lt;/code&gt; 方法，这能延迟对象的释放。但一般来说，并不需要显式使用 &lt;code&gt;@autoreleasepool{ }&lt;/code&gt;，这是因为在主线程 RunLoop 的每个周期中都会自动进行自动释放池的创建和销毁。&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://xuhaodong1.github.io/categories/iOS/"/>
    
    
    <category term="内存管理" scheme="https://xuhaodong1.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>iOS中的内存管理｜ARC</title>
    <link href="https://xuhaodong1.github.io/2023/07/20/iOS%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BD%9CARC/"/>
    <id>https://xuhaodong1.github.io/2023/07/20/iOS%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BD%9CARC/</id>
    <published>2023-07-20T01:49:00.000Z</published>
    <updated>2023-07-20T06:23:27.734Z</updated>
    
    <content type="html"><![CDATA[<h2 id="iOS-采用什么内存管理方式"><a href="#iOS-采用什么内存管理方式" class="headerlink" title="iOS 采用什么内存管理方式"></a>iOS 采用什么内存管理方式</h2><p>在 iOS 中，采用自动引用计数（ARC，Automatic Reference Counting）机制来进行内存管理，让编译器来帮助内存管理，无需程序员手动键入 retain、release 等代码进行内存管理，取而代之的是由编译器来插入相关内存管理的代码。这一点的好处在于能够降低程序崩溃、内存泄漏等风险的同时，很大程度上也能够减少程序员的工作量。</p><span id="more"></span><p>与引用计数相对应的，是垃圾回收（GC，Garbage Collection）机制，JavaScript、Java、Golong 等语言都采用这种机制进行内存管理，它将所有的对象看成一个集合，然后在 GC 循环中定时监测活动对象和非活动对象，及时将这些用不到的非活动对象释放以避免内存泄漏。</p><p>相对于 GC 来说，引用计数是局部的，在运行时无需额外开销，同时其内存回收是平稳、时机明确的，没有被持有的对象会被立即释放，但同时也引入了循环引用导致的内存泄漏这种新的内存管理问题。</p><h2 id="内存管理的相关操作"><a href="#内存管理的相关操作" class="headerlink" title="内存管理的相关操作"></a>内存管理的相关操作</h2><p>当生成新的对象时，其引用计数为 1，当有其他指针持有这个对象时，其引用计数加 1，当其他指针释放这个对象时，其引用计数减 1，当这个对象的引用计数变为 0 时，对象会被废弃。上文中出现的“生成”、“持有”、“释放”、“废弃”对应的 Objective-C 的方法如下表：</p><table><thead><tr><th align="left">对象操作</th><th>Objective-C 方法</th></tr></thead><tbody><tr><td align="left">生成并持有对象</td><td>alloc / new / copy / mutableCopy 方法</td></tr><tr><td align="left">持有对象</td><td>retain 方法</td></tr><tr><td align="left">释放对象</td><td>release 方法</td></tr><tr><td align="left">废弃对象</td><td>dealloc 方法</td></tr></tbody></table><p>在 MRC 机制下，由于需要程序员手动插入 retain、release 代码，无需考虑引用计数，按如下思考方式进行代码编写就可以管理好内存：</p><ul><li>自己生成的对象，自己所持有。</li><li>非自己生成的对象，自己也能持有。</li><li>不再需要自己持有的对象时释放。</li><li>非自己持有的对象无法释放。</li></ul><p>但 ARC 中，由于交给了编译器进行内存管理，每个对象都是相当于强引用，但这会产生循环引用的问题，由于引用计数不能达到 0，导致对象无法被释放，因此引入了所有权修饰符来解决这个问题：</p><ul><li><p><code>__strong</code>：对象的默认所有权修饰符，它表示对对象的“强引用”，在超出其作用域时，强引用失效。</p></li><li><p><code>__weak</code>：使用 <code>__weak </code> 修饰的对象不会持有对象，因此不会使对象的引用计数加 1，同时弱引用指向的对象被废弃时，弱引用会指向 nil，利用这一点可以来解决循环引用的场景。</p></li><li><p><code>__unsafe_unretained</code>：与 <code>__weak</code> 类似，<code>__unsafe_unretained</code> 修饰的对象不会持有对象，但在指向的对象被废弃时，不会指向 nil，会变成野指针。使用 <code>__unsafe_unretained</code> 时需要明确清楚它的生命周期小于或者等于被指向对象的生命周期，它与 Swift 中的 <code>unowned</code> 类似，同时它的效率也比 <code>__weak</code> 高。</p></li><li><p><code>__autoreleasing</code>：使用 <code>__autoreleaseing</code> 修饰的对象会被注册到 AutoReleasePool 中，会延迟到 AutoReleasePool 被销毁时才会调用对象的 release 方法，这会延长对象的生命周期。但由于编译器优化的原因，实际用到的地方是很少的。</p></li></ul><blockquote><p>循环引用：对象间的相互强引用产生有向环，导致有向环中的每一个节点都无法被释放（没有对象的引用计数为 0），进而会导致内存泄漏。</p><pre><code class="objective-c">// test 持有自身导致的循环引用id test = [[Test alloc] init];[test setObject: test];</code></pre></blockquote><h2 id="alloc-amp-retain-amp-release-amp-dealloc-源码探究"><a href="#alloc-amp-retain-amp-release-amp-dealloc-源码探究" class="headerlink" title="alloc &amp; retain &amp; release &amp; dealloc 源码探究"></a>alloc &amp; retain &amp; release &amp; dealloc 源码探究</h2><h3 id="alloc"><a href="#alloc" class="headerlink" title="alloc"></a><code>alloc</code></h3><p>对象内存分配的主要逻辑集中在 <code>callAlloc</code> 与 <code>_class_createInstanceFromZone</code> 方法里。为了提升效率，其在 <code>callAlloc</code> 里判断了 <code>hasCustomAWZ</code>（自定义的 allocWithZone 方法），没有执行 <code>_objc_rootAllocWithZone</code>，有则进入消息派发 <code>allocWithZone</code>。NSZone 已被系统忽略，由于历史遗留原因才得以保留，因此虽然有许多跳转流程，但最终都会指向 <code>_class_createInstanceFromZone</code> 方法。</p><pre><code class="objc">static ALWAYS_INLINE idcallAlloc(Class cls, bool checkNil, bool allocWithZone=false){#if __OBJC2__    if (slowpath(checkNil &amp;&amp; !cls)) return nil;    if (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) {        return _objc_rootAllocWithZone(cls, nil);    }#endif      if (allocWithZone) {        return ((id(*)(id, SEL, struct _NSZone *))objc_msgSend)(cls, @selector(allocWithZone:), nil);    }    return ((id(*)(id, SEL))objc_msgSend)(cls, @selector(alloc));}</code></pre><p><code>_class_createInstanceFromZone</code> 主要做了三件事，获取对象内存占用大小并分配、设置 <code>isa</code> 指针、以及执行 C++ 构造方法。</p><p>获取内存占用并分配：<code>cls-&gt;instanceSize(extraBytes);</code> 通过在 <code>cache</code> 或者 <code>ro()-&gt;instanceSize </code> (编译时确定)获取占用内存，并进行内存对齐，最后调用 <code>calloc</code> 方法进行内存分配。</p><p>设置 <code>isa</code> 指针：设置如 has_cxx_dtor（是否有 C++ 析构函数）、shiftcls（类对象或者元类对象的地址）、extra_rc（引用计数） 等信息。</p><p>执行 C++ 构造方法：从基类开始向下递归执行 C++ 的构造函数。</p><pre><code class="objc">// 简化后代码static ALWAYS_INLINE id_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone,                              int construct_flags = OBJECT_CONSTRUCT_NONE,                              bool cxxConstruct = true,                              size_t *outAllocatedSize = nil){    bool hasCxxCtor = cxxConstruct &amp;&amp; cls-&gt;hasCxxCtor();    bool hasCxxDtor = cls-&gt;hasCxxDtor();    bool fast = cls-&gt;canAllocNonpointer();    size_t size;    // 获取实例变量内存占用大小    size = cls-&gt;instanceSize(extraBytes);    id obj;    obj = (id)calloc(1, size);           // 设置 isa 指针    obj-&gt;initInstanceIsa(cls, hasCxxDtor);    if (fastpath(!hasCxxCtor)) {        return obj;    }    construct_flags |= OBJECT_CONSTRUCT_FREE_ONFAILURE;    // 执行 C++ 构造函数    return object_cxxConstructFromClass(obj, cls, construct_flags);}</code></pre><blockquote><p>NSZone：它是为了防止内存碎片化而引入的结构，对内存分配的区域本身进行多重化管理，根据使用对象的目的、对象的大小分配内存，从而提高了内存管理的效率。但目前运行时系统中的内存管理本身已极具效率，使用 NSZone 来管理反而会引起内存使用效率低下以及源代码复杂化等问题，因此运行时只是简单地忽略了 NSZone 的概念。</p></blockquote><h4 id="retain"><a href="#retain" class="headerlink" title="retain"></a>retain</h4><p>retain 会将对象的引用计数 + 1，其主要逻辑主要集中在 rootRetain 方法中，引用计数一般会存储在两个地方，首先是 isa 指针的 extra_rc 域中，若有溢出则会将一半的引用计数值存储到 SideTable 中。</p><pre><code class="objective-c">// 简化后代码ALWAYS_INLINE idobjc_object::rootRetain(bool tryRetain, objc_object::RRVariant variant){    bool sideTableLocked = false;    bool transcribeToSideTable = false;    isa_t oldisa;    isa_t newisa;    oldisa = LoadExclusive(&amp;isa.bits); // 加载 isa 指针    do {        newisa = oldisa;        uintptr_t carry;        newisa.bits = addc(newisa.bits, RC_ONE, 0, &amp;carry);  // extra_rc++                  // 若 newisa.extra_rc++ 溢出，再调用一次，将 variant 设置为 RRVariant::Full        if (slowpath(carry)) {            if (variant != RRVariant::Full) {                ClearExclusive(&amp;isa.bits);                return rootRetain_overflow(tryRetain);            }            // 留下一半的引用计数值，并将另一半拷贝到 SideTable中            if (!tryRetain &amp;&amp; !sideTableLocked) sidetable_lock();            sideTableLocked = true;            transcribeToSideTable = true;            newisa.extra_rc = RC_HALF;            newisa.has_sidetable_rc = true;        }    } while (slowpath(!StoreExclusive(&amp;isa.bits, &amp;oldisa.bits, newisa.bits)));    if (variant == RRVariant::Full) {        if (slowpath(transcribeToSideTable)) {            // 拷贝一半的引用计数值到 SideTable 中            sidetable_addExtraRC_nolock(RC_HALF);        }        if (slowpath(!tryRetain &amp;&amp; sideTableLocked)) sidetable_unlock();    }    return (id)this;}</code></pre><p>关于 SideTable，其本身是全局的 SideTables() 的 value 元素，key 则是通过对象指针地址的偏移映射，找到属于对象的 SideTable，再通过对象的地址，获得属于对象的引用计数表。当 SideTable 中对象的引用计数溢出时，会将标志位（SIDE_TABLE_RC_PINNED）置为 1。</p><pre><code class="c++">// 通过对象的地址偏移与 StripeCount 大小映射到属于对象的 SideTable 的下标static unsigned int indexForPointer(const void *p) {    uintptr_t addr = reinterpret_cast&lt;uintptr_t&gt;(p);    return ((addr &gt;&gt; 4) ^ (addr &gt;&gt; 9)) % StripeCount;}// 加入额外的引用计数到 SideTable 中bool objc_object::sidetable_addExtraRC_nolock(size_t delta_rc){    SideTable&amp; table = SideTables()[this];    size_t&amp; refcntStorage = table.refcnts[this];    size_t oldRefcnt = refcntStorage;    if (oldRefcnt &amp; SIDE_TABLE_RC_PINNED) return true;    uintptr_t carry;    size_t newRefcnt =         addc(oldRefcnt, delta_rc &lt;&lt; SIDE_TABLE_RC_SHIFT, 0, &amp;carry);    if (carry) {        refcntStorage =            SIDE_TABLE_RC_PINNED | (oldRefcnt &amp; SIDE_TABLE_FLAG_MASK);        return true;    }    else {        refcntStorage = newRefcnt;        return false;    }}</code></pre><h4 id="release"><a href="#release" class="headerlink" title="release"></a>release</h4><p>与 retain 对应，release 方法的主要逻辑集中在 rootRelease 中，它会将对象的引用计数 - 1，如果发生下溢（underflow），则会从 SideTable 中借取一半引用计数值，若引用计数为 0 则销毁对象。</p><pre><code class="c++">// 简化后代码ALWAYS_INLINE boolobjc_object::rootRelease(bool performDealloc, objc_object::RRVariant variant){    if (slowpath(isTaggedPointer())) return false;    bool sideTableLocked = false;    isa_t newisa, oldisa;    oldisa = LoadExclusive(&amp;isa.bits);retry:    do {        newisa = oldisa;        uintptr_t carry;        newisa.bits = subc(newisa.bits, RC_ONE, 0, &amp;carry);  // extra_rc--        if (slowpath(carry)) { // 发生下溢            goto underflow;        }    } while (slowpath(!StoreReleaseExclusive(&amp;isa.bits, &amp;oldisa.bits, newisa.bits)));        // 销毁对象    if (slowpath(newisa.isDeallocating()))        goto deallocate;    return false; underflow:    newisa = oldisa;    if (slowpath(newisa.has_sidetable_rc)) {        if (variant != RRVariant::Full) {            ClearExclusive(&amp;isa.bits);            return rootRelease_underflow(performDealloc);        }              auto borrow = sidetable_subExtraRC_nolock(RC_HALF);                bool emptySideTable = borrow.remaining == 0;              if (borrow.borrowed &gt; 0) {            newisa.extra_rc = borrow.borrowed - 1;            newisa.has_sidetable_rc = !emptySideTable;        }        if (emptySideTable)                sidetable_clearExtraRC_nolock();    }deallocate:    if (performDealloc) {        ((void(*)(objc_object *, SEL))objc_msgSend)(this, @selector(dealloc));    }    return true;}</code></pre><h4 id="dealloc"><a href="#dealloc" class="headerlink" title="dealloc"></a>dealloc</h4><p>对象内存释放的主要逻辑集中在 <code>rootDealloc</code> 与 <code>objc_destructInstance</code> 方法里。其中，taggedPointer 对象无需释放(其在栈上存储)、若同时满足以下条件则直接 <code>free</code>，否则进入 <code>objc_destructInstance</code>。</p><p><code>dealloc</code> 在执行最终释放操作（release）的那个线程中被执行，而不是主线程；</p><p>在 <code>dealloc</code> 也不要使用 <code>__weak __typeof(self)weak_self = self</code> 这样的代码，这是因为在 weak 注册时会判断其是否处于 <code>deallocating</code> 状态，会产生崩溃。</p><ol><li><code>isa.nonpointer</code> 为 1，即存在 <code>ISA_BITFIELD</code> 位域数据</li><li>此对象不是其他对象的弱引用对象</li><li>此对象没有关联对象</li><li>没有 C++ 的析构函数</li><li>不存在 SideTable 记录引用计数</li></ol><pre><code class="objc">inline voidobjc_object::rootDealloc(){    if (isTaggedPointer()) return;  // fixme necessary?    if (fastpath(isa.nonpointer                     &amp;&amp;                 !isa.weakly_referenced             &amp;&amp;                 !isa.has_assoc                     &amp;&amp;#if ISA_HAS_CXX_DTOR_BIT                 !isa.has_cxx_dtor                  &amp;&amp;#else                 !isa.getClass(false)-&gt;hasCxxDtor() &amp;&amp;#endif                 !isa.has_sidetable_rc))    {        assert(!sidetable_present());        free(this);    }     else {        object_dispose((id)this);    }}</code></pre><p><code>objc_destructInstance</code> 则是清理对象关联的资源，C++ 的析构函数、关联对象、SideTable 中的弱引用指针和引用计数表，之后再 <code>free</code>。在 C++ 析构函数中，会遍历其所有的实例变量，形如 <code>objc_storeStrong(&amp;ivar, null)</code> 调用，则会对所有的实例变量进行 release，并将其置为 nil。同时经由编译器插入类似 <code>[super dealloc]</code>，则会实现了由子类开始遍历到基类的 <code>dealloc</code>。</p><pre><code class="objc">void *objc_destructInstance(id obj) {    if (obj) {        // Read all of the flags at once for performance.        bool cxx = obj-&gt;hasCxxDtor();        bool assoc = obj-&gt;hasAssociatedObjects();        // This order is important.        if (cxx) object_cxxDestruct(obj);        if (assoc) _object_remove_assocations(obj, /*deallocating*/true);        obj-&gt;clearDeallocating();    }    return obj;}</code></pre><h2 id="不要在-init-和-dealloc-中调用-accessor-方法"><a href="#不要在-init-和-dealloc-中调用-accessor-方法" class="headerlink" title="不要在 init 和 dealloc 中调用 accessor 方法"></a>不要在 init 和 dealloc 中调用 accessor 方法</h2><p>在 <code>init</code>、和 <code>dealloc</code> 中，这个阶段处于未完全初始化成功或者正在废弃阶段，同时由于继承、多态特性，本来目的到调用父类的方法调用到了子类，就可能会出现错误，例如在 init 中：</p><pre><code class="objc">@interface BaseClass : NSObject@property(nonatomic) NSString* info;@end@implementation BaseClass- (instancetype)init {      if ([super init]) {        self.info = @"baseInfo";     }     return self;}@end@interface SubClass : BaseClass@end@interface SubClass ()@property (nonatomic) NSString* subInfo;@end@implementation SubClass- (instancetype)init {     if (self = [super init]) {         self.subInfo = @"subInfo";     }     return self;}- (void)setInfo:(NSString *)info {    [super setInfo:info];     NSString* copyString = [NSString stringWithString:self.subInfo]; NSLog(@"%@",copyString);}@end</code></pre><p>这时候创建一个 SubClass 实例变量，由于继承、多态特性会调用到子类的 <code>setInfo</code>，子类的 accessor 实现的代码完全以子类已完全初始化的前提编写的，此时的 <code>subInfo</code> 还并未完全初始化，进而会造成崩溃。</p><p>这一点与 Swift 中，构造器在第一阶段构造完成之前，不能调用任何实例方法，不能读取任何实例属性的值，不能引用 <code>self</code> 作为一个值类似。</p><p>第一阶段：类中的每个存储型属性赋一个初始值。</p><p>第二阶段：给每个类一次机会，在新实例准备使用之前进一步自定义它们的存储型属性。</p><p>两段式构造过程的使用让构造过程更安全，同时在整个类层级结构中给予了每个类完全的灵活性。两段式构造过程可以防止属性值在初始化之前被访问，也可以防止属性被另外一个构造器意外地赋予不同的值。</p><blockquote><p>在《Effective Objective-C 2.0 编写高质量iOS与OS X代码的有效52个有效方法》中也指出：</p><p>在dealloc里不要调用属性的存取方法，因为有人可能会覆写这些方法，并于其中做一些无法再回收阶段安全执行的操作。此外，属性可能正处于“键值观察”(Key-Value Observation，KVO)机制的监控之下，该属性的观察者(Observer)可能会在属性值改变时“保留”或使用这个即将回收的对象。这种做法会令运行期系统的状态完全失调，从而导致一些莫名其妙的错误。</p></blockquote><h2 id="🔗"><a href="#🔗" class="headerlink" title="🔗"></a>🔗</h2><p>[1] <a href="https://book.douban.com/subject/24720270/">Objective-C 高级编程 iOS与OS X多线程和内存管理</a></p><p>[2] <a href="http://blog.sunnyxx.com/2014/04/02/objc_dig_arc_dealloc/">ARC下dealloc过程及.cxxdestruct的探究</a></p><p>[3] <a href="https://draveness.me/rr/">黑箱中的 retain 和 release</a></p><p>[4] <a href="https://cloud.tencent.com/developer/article/1143323">为什么不能在init和dealloc函数中使用accessor方法</a></p><p>[5] <a href="https://swift.bootcss.com/02_language_guide/14_Initialization#memberwise-initializers-for-structure-types">Swift构造过程</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;iOS-采用什么内存管理方式&quot;&gt;&lt;a href=&quot;#iOS-采用什么内存管理方式&quot; class=&quot;headerlink&quot; title=&quot;iOS 采用什么内存管理方式&quot;&gt;&lt;/a&gt;iOS 采用什么内存管理方式&lt;/h2&gt;&lt;p&gt;在 iOS 中，采用自动引用计数（ARC，Automatic Reference Counting）机制来进行内存管理，让编译器来帮助内存管理，无需程序员手动键入 retain、release 等代码进行内存管理，取而代之的是由编译器来插入相关内存管理的代码。这一点的好处在于能够降低程序崩溃、内存泄漏等风险的同时，很大程度上也能够减少程序员的工作量。&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://xuhaodong1.github.io/categories/iOS/"/>
    
    
    <category term="内存管理" scheme="https://xuhaodong1.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>nihao&#39; 2022年终总结</title>
    <link href="https://xuhaodong1.github.io/2022/12/24/2022-12-24-nihao%E7%9A%842022%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>https://xuhaodong1.github.io/2022/12/24/2022-12-24-nihao%E7%9A%842022%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</id>
    <published>2022-12-23T16:00:00.000Z</published>
    <updated>2023-06-22T15:21:22.569Z</updated>
    
    <content type="html"><![CDATA[<p>2022 对我来说过的很快，还记得 2022 年年初的时候，杭州刚好突发了疫情，而我所在的小区刚好是疫情的重点防护区。因此，理所当然的我被拉进了酒店隔离，每天过着核酸 - 盒饭的生活，这几乎花光了春节的时光；每天都有一次的核酸检测，几乎时间都分配在了早上 6 点左右，与此同时，走廊上的大喇叭的噪音也不堪入耳，起初最难以接受的是鼻咽拭子，每次做完都感觉很生气，不过好在我都能接受。</p><span id="more"></span><p>现在看来，我很庆幸在那个时候能够有一段独立思考时光。</p><p>心态的第一个转变是别给自己设限，自己什么都可以做，也愿意尝试新鲜的东西，只要我愿意。</p><h2 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h2><p>读书的人是很不常见的，一生中遇到了那么多人，主动读书的人只占了很少的一部分，我们每一个人都知道阅读是一件好事，但是却都不愿意去尝试，我认为造成这种状况的原因是人的惰性思维，跟人不喜欢跳出自己的舒适圈很相像。</p><p><img src="/images/blog/IMG_0120.jpeg" alt="IMG_0120"></p><p>不过遗憾的事，看的书不算多，甚至有数本都是看到一半就没看了。同时，每天分配读书的时间没有一个良好的规律，有些时候抽不出精力来看，就把完完整整看完的按其时间顺序做一个简单概述：</p><p>《谁杀了她》：</p><p>悬疑作家东野圭吾的短篇小说，不过这类书籍主要偏向悬疑与解密，就个人而言触动不是很大，不算很推荐。</p><p>《人类简史：从动物到上帝》：</p><p>尤瓦尔·赫拉利的人类简史三部曲的首部，主要讲述了人类从原始生活到近代的种种变化，从认知革命、农业革命和科学革命。其中许多观点都给人耳目一新的感受，甚至称之为振聋发聩也不足为过，十分推荐一读。</p><p>《刀锋》：</p><p>受 B 站某 UP 主推荐，刀锋算毛姆中晚年中反响热烈的一部作品。讲述了主角 “拉里” 的一生，拉一份之前写的书评吧：</p><p>战争的剧烈冲击让拉里选择了停下来，好好看看这个世界，寻找生命的意义。在寻找过程中游历四方，最终他淡泊且宁静，追寻着心中的自由。让我羡慕且害怕的，是对任何事都有一份坚定的从容和果断。 </p><p>《半小时漫画经济学》：</p><p>一部趣味漫画式的书，介绍了经济学方面的基础知识，简单且诙谐。如果你想了解有关经济学方面的知识，这本书可以作为一本简单的启蒙书籍。</p><p>《富爸爸穷爸爸》：</p><p>罗伯特 · 清崎的富爸爸系列的首部作品，以倡导“财商”的教育成为畅销书，可以作为经济方面的教育启蒙书。其中有许多观点比较实用或者可以称之为鸡血，但总体而言它引导你鼓起勇气去做提升自己的资产，倡导多学习多丰富自我。</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><img src="/images/blog/Screenshot 2022-12-24 at 22.39.00.png" alt="Screenshot 2022-12-24 at 22.39.00" style="zoom:100%;"><p>起初学算法单纯是为了面试，不过后来慢慢变成了一种习惯，进而演变成了一种兴趣。</p><p>为此我参加了差不多半年的 LeetCode 周赛，在 Github 上开了一个仓库记录 LeetCode 每日一题 <a href="https://github.com/xuhaodong1/nihao_algorithm_notes">nihao_algorithm_nots</a>，后面希望能够多写一写题解，能够有系统性的总结。</p><p>如果你也对算法感兴趣，不妨联系我一起学习与进步。</p><h2 id="Blog："><a href="#Blog：" class="headerlink" title="Blog："></a>Blog：</h2><img src="/images/blog/image-20221226101049638.png" alt="image-20221226101049638" style="zoom:80%;"><p>2022 年一共产出 7 篇博客，平均 1.7 个月出产一篇，对我来说不算高效，但也绝对不算低产。每一篇博客都算是良苦用心，经历了许多时间的沉淀，查阅了相当多的资料。你甚至觉得这里我可能在自卖自夸，不过好像确实有点 😂 …</p><p>总的来说，我认为进步很大。从第一篇不知道怎么概括一个 Blog 的结构，怎么组织流畅的语言，到现在的有一些人认可的程度。最初写的时候对我而言是比较困难的，例如你查到一个知识点，进而牵引出另一个知识点；如果这个知识点是前置的，那么你就必须得先学前一个，这样嵌套几次对文章的整体思路就很容易混乱，不过这样刨根问底也有一个好处，就是能够学的更加深、更加广，以后再遇到类似的问题能有一个大致的思路。</p><h2 id="2023-年的目标"><a href="#2023-年的目标" class="headerlink" title="2023 年的目标"></a>2023 年的目标</h2><ul><li><input disabled="" type="checkbox"> 5 篇原创技术文章、2 篇日常阅读文章</li><li><input disabled="" type="checkbox"> 阅读 5 本以上书籍</li><li><input disabled="" type="checkbox"> 系统性题解总结 5 篇</li></ul><p>相对来说，我的目标比较保守，甚至许多渴望尝试的方面都没有涉及。不过今年是记录总结的第一年，算是给自己留有余地，以后能够根据自己的落实情况进行调整。</p><p>2023 年的我，希望能保持初心，不断前行。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;2022 对我来说过的很快，还记得 2022 年年初的时候，杭州刚好突发了疫情，而我所在的小区刚好是疫情的重点防护区。因此，理所当然的我被拉进了酒店隔离，每天过着核酸 - 盒饭的生活，这几乎花光了春节的时光；每天都有一次的核酸检测，几乎时间都分配在了早上 6 点左右，与此同时，走廊上的大喇叭的噪音也不堪入耳，起初最难以接受的是鼻咽拭子，每次做完都感觉很生气，不过好在我都能接受。&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xuhaodong1.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="https://xuhaodong1.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="年终总结" scheme="https://xuhaodong1.github.io/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>CocoaPods使用指南</title>
    <link href="https://xuhaodong1.github.io/2022/12/20/2022-12-20-CocoaPods%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>https://xuhaodong1.github.io/2022/12/20/2022-12-20-CocoaPods%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</id>
    <published>2022-12-20T12:57:00.000Z</published>
    <updated>2023-06-22T15:21:22.569Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于大多数软件开发团队来说，依赖管理工具必不可少，它能针对开源和私有依赖进行安装与管理，从而提升开发效率，降低维护成本。针对不同的语言与平台，其依赖管理工具也各有不同，例如 npm 管理 Javascript、Gradle 、Maven 管理 Jar 包、pip 管理 Python 包，Bundler、RubyGems 等等。本文聚焦于 iOS 方面，对 CocoaPods 的使用和部分原理进行阐述。</p><span id="more"></span><h2 id="简单易用的-CocoaPods"><a href="#简单易用的-CocoaPods" class="headerlink" title="简单易用的 CocoaPods"></a>简单易用的 CocoaPods</h2><p>对于 iOSer 来说，CocoaPods 并不陌生，几乎所有的 iOS 工程都会有它的身影。CocoaPods 采用 Ruby 构建，它是 Swift 和 Objective-C Cocoa 项目的依赖管理工具。在 MacOS 上，推荐使用默认的 Ruby 进行安装 (以下操作均在 CocoaPods 1.10.1、Ruby 2.7.2 进行)：</p><pre><code class="shell">sudo gem install cocoapods</code></pre><p>如果安装成功，便可以使用 pod 的相关命令了。针对一个简单的项目来说，只需三步便可引入其他的依赖：</p><ol><li>创建 Podfile 文件( CocoaPods 提供了 pod init 命令创建)</li><li>对 Podfile 文件进行编写，添加依赖的库，版本等信息。</li><li>在命令行执行 <code>pod install</code> 命令</li></ol><p>顺利的话，这时在项目目录下会出现以下文件：</p><ul><li>.xcworkspace：CocoaPods 将项目分为了主工程与依赖工程(Pods)。与 .xcodeproj 相比 .xcworkspace 对于管理多个项目的能力更强，你也可以将复杂的大型应用转换为以 .xcworkspace 构建的多个兄弟项目，从而更轻松的维护和共享功能。</li><li>Podfile.lock：记录并跟踪依赖库版本，将依赖库锁定于某个版本。</li><li>Pods 文件夹：存放依赖库代码。</li><li>Pods/Manifest.lock：每次 <code>pod install</code> 时创建的 Podfile.lock 的副本，用于比较这两个文件。一般来说，Podfile.lock 会纳入版本控制管理，而 Pods 文件夹则不会纳入版本控制变更；这意味着 Podfile.lock 表示项目应该依赖的库版本信息，而 Manifest.lock 则代表本地 Pods 的依赖库版本信息。在 pod install 后会将脚本插入到 Build Phases，名为 <code>[CP] Check Pods Manifest.lock</code>，从而保证开发者在运行 app 之前能够更新 Pods，以确保代码是最新的。</li></ul><h2 id="pod-install-vs-pod-update"><a href="#pod-install-vs-pod-update" class="headerlink" title="pod install vs. pod update"></a>pod install vs. pod update</h2><ul><li><code>pod install</code>：在每一次编辑 Podfile 以添加、更新或删除 pod 时使用。它会下载并安装新的 Pod，并将其版本信息写入 Podfile.lock 中。</li><li><code>pod outdated</code>：列出所有比 Podfile.lock 中当前记录的版本 newer 版本的 pod。</li><li><code>pod update [PODNAME]</code>：CocoaPods 会查找 newer 版本的 PODNAME，同时将 pod 更新到可能的最新版本(须符合 Podfile 限制)。若没有 PODNAME，则会将每一个 pod 更新到可能的最新版本。</li></ul><p>一般来说，每次编辑 Podfile 时使用 <code>pod install</code>，仅在需要更新某个 pod 版本(所有版本)时才使用 pod update。同时，需提交 Podfile.lock 文件而不是 Pods 文件夹来达到同步所有 pod 版本的目的。</p><p>ps: newer 代表更加新的，若采用中文理解起来比较别扭。</p><h2 id="Podfile-语法规范"><a href="#Podfile-语法规范" class="headerlink" title="Podfile 语法规范"></a>Podfile 语法规范</h2><p>Podfile 描述了一个或多个 Xcode 项目的 target 依赖关系，它是一种 DSL，了解它对我们使用好 CocoaPods 是一个必不可少的步骤。下面列出其相关的语法规范：</p><h3 id="Root-Options"><a href="#Root-Options" class="headerlink" title="Root Options"></a>Root Options</h3><p>install：指定 CocoaPods 安装 Podfile 时使用的安装方法和选项。如：</p><pre><code class="ruby">install! 'cocoapods',         :deterministic_uuids =&gt; false,         :integrate_targets =&gt; false</code></pre><ul><li><code>:clean</code>：根据 podspec 和项目支持平台的指定，清理所有不被 pod 使用的文件，默认为 true。</li><li><code>:deduplicate_targets</code>：是否对 pod target 进行重复数据删除，默认为 true。</li><li><code>:deterministic_uuids</code>：创建 pod project 是否产生确定性 UUID，默认为 true。</li><li><code>:integrate_targets</code>：是否继承到用户项目中，为 false 会将 Pod 下载并安装到到 project_path/Pods 目录下，默认为 true。</li><li><code>:lock_pos_sources</code>：是否锁定 pod 的源文件，当 Xcode 尝试修改时会提示解锁文件，默认为 true。</li><li><code>:warn_for_multiple_pod_sources</code>：当多个 source 包含同名同版本 pod 时是否发出警告，默认为 true。</li><li><code>:warn_for_unused_master_specs_repo</code>：如果没有明确指出 master specs repo 的 git 是否发出警告，默认为 true。</li><li><code>:share_schemes_for_development_pods</code>：是否为开发中的 pod 分享 schemes，默认为 false。</li><li><code>:disable_input_output_paths</code>：是否禁用 CocoaPods 脚本阶段的输入输出路径（Copy Frameworks 和 Copy Resources），默认为 false。</li><li><code>:preserve_pod_file_structure</code>：是否保留所有 pod 的文件结构，默认为 false。</li><li><code>:generate_multiple_pod_projects</code>：是否为每一个 pod target 生成 一个 project，生成与 Pods/Pods 文件夹中，默认为 false。</li><li><code>:incremental_installation</code>：仅对自上次安装的 target 与其关联的 project 的变更部分进行重新生成，默认为 false。</li><li><code>:skip_pods_project_generation</code>：是否跳过生成 Pods.xcodeproj 并仅进行依赖项解析与下载，默认为 false。</li></ul><p>ensure_bundler!：当 bundler 版本不匹配时发出警告。</p><pre><code class="ruby">ensure_bundler! '~&gt; 2.0.0'</code></pre><h3 id="Dependencies"><a href="#Dependencies" class="headerlink" title="Dependencies"></a>Dependencies</h3><p><strong>pod</strong>：指定项目的依赖项</p><ul><li>依赖版本控制：=、&gt;、&gt;=、&lt;、&lt;= 为字面意思；~&gt; 0.1.2 表示 0.1.2 &lt;= currVersion &lt; 0.2 之间的符合要求的最新版本版本。</li><li>Build configurations：默认依赖安装在所有的构建配置中，但也可仅在指定构建配置中启用。</li><li>Modular Headers：用于将 pod 转换为 module 以支持模块，这时在 Swift 中可以不用借助 <code>bridging-header</code> 桥接就可以直接导入，简化了 Swift 引用 Objective-C 的方式；也可以采用 <code>use_modular_headers!</code> 进行全局的变更。</li><li>Source：指定具有依赖项的源，同时会忽略全局源。</li><li>Subspecs：默认会安装所有的 subspecs，但可制定安装某些 subspecs。</li><li>Test Specs：默认不会安装 test specs，但可选择性安装 test specs。</li><li>Local path：将开发的 pod 与其客户端一起使用，可采用 path。</li><li>指定某个特殊或者更为先进的 pod 版本</li></ul><pre><code class="ruby"># 依赖版本控制pod 'Objection', '~&gt; 0.9' # Build configurationspod 'PonyDebugger', :configurations =&gt; ['Debug', 'Beta'] # Modular Headerspod 'SSZipArchive', :modular_headers =&gt; true # Sourcepod 'PonyDebugger', :source =&gt; 'https://github.com/CocoaPods/Specs.git'# Subspecspod 'QueryKit', :subspecs =&gt; ['Attribute', 'QuerySet'] # Test Specspod 'AFNetworking', :testspecs =&gt; ['UnitTests', 'SomeOtherTests']# Local pathpod 'AFNetworking', :path =&gt; '~/Documents/AFNetworking'# 指定某个特殊或者更为先进的 Pod 版本pod 'AFNetworking', :git =&gt; 'https://github.com/gowalla/AFNetworking.git', :branch =&gt; 'dev'pod 'AFNetworking', :git =&gt; 'https://github.com/gowalla/AFNetworking.git', :tag =&gt; '0.7.0'pod 'AFNetworking', :git =&gt; 'https://github.com/gowalla/AFNetworking.git', :commit =&gt; '082f8319af'# 指定某个 podspecpod 'JSONKit', :podspec =&gt; 'https://example.com/JSONKit.podspec'</code></pre><p><strong>inherit</strong>：设置当前 target 的继承模式。</p><p><code>:complete</code> 继承父级 target 的所有行为，<code>:none</code> 不继承父级 target 的任何行为，<code>:search_paths</code> 仅继承父级的搜索路径。</p><pre><code class="ruby">target 'App' do  target 'AppTests' do    inherit! :search_paths  endend</code></pre><p><strong>target</strong>：与 Xcode 中的 target 相对应，block 中是 target 的依赖项。</p><p>默认情况下，target 包含在父级 target 定义的依赖项，也即 <code>inherit!</code> 为 <code>:complete</code>。关于 <code>:complete</code> 和 <code>:search_paths</code>，<code>:complete</code> 会拷贝父级 target 的 pod 副本，而 <code>:search_paths</code> 则只进行 <code>FRAMEWORK_SEARCH_PATHS</code> 和 <code>HEADER_SEARCH_PATHS</code> 的相关拷贝，具体可通过比对 Pods/Target Support Files 的相关文件得以验证，一般在 <code>UnitTests</code> 中使用，以减少多余的 <code>install_framework</code> 过程。</p><pre><code class="ruby">target 'ShowsApp' do  pod 'ShowsKit'  # 拥有 ShowsKit 和 ShowTVAuth 的拷贝  target 'ShowsTV' do    pod 'ShowTVAuth'  end  # 拥有 Specta 和 Expecta 的拷贝  # 并且能够通过 ShowsApp 进行访问 ShowsKit, 相当于 ShowsApp 是 ShowsTests 的宿主APP  target 'ShowsTests' do    inherit! :search_paths    pod 'Specta'    pod 'Expecta'  endend</code></pre><p><strong>abstract_target</strong>：定义 <code>abstract_target</code>，方便 target 进行依赖继承，在 CocoaPods 1.0 版本之前为 <code>link_with</code>。</p><pre><code class="ruby">abstract_target 'Networking' do  pod 'AlamoFire'  target 'Networking App 1'  target 'Networking App 2'end</code></pre><p><strong>abstract</strong>：表示当前 target 是抽象的，不会链接到 Xcode 的 target 中。</p><p><strong>script_phase</strong>：添加脚本阶段。</p><p>在执行完 <code>pod install</code> 之后 CocoaPods 会将脚本添加到对应的 <code>target build phases</code>。</p><pre><code class="ruby">target 'App' do    script_phase {        :name =&gt; 'scriptName' # 脚本名称,        :script =&gt; 'echo "nihao"' # 脚本内容,        :execution_position =&gt; :before_compile / :after_compile        :shell_path =&gt; '/usr/bin/ruby' # 脚本路径        :input_files =&gt; ['/input/filePath'], # 输入文件        :output_files =&gt; ['/outpput/filePath'] # 输出文件    }end</code></pre><h3 id="Target-configuration"><a href="#Target-configuration" class="headerlink" title="Target configuration"></a>Target configuration</h3><p><strong>platform</strong>：指定其构建平台。</p><p>默认值为 iOS 4.3、OSX 10.6、tvOS 9.0 和 watchOS 2.0。CocoaPods 1.0 之前的版本为 xcodeproj</p><pre><code class="ruby">platform :ios, '4.0'</code></pre><p><strong>project</strong>：指定包含 target 的 Xcode project。这一般在 workspace 存在多个 xcode project 中使用：</p><pre><code class="ruby"># 在 FastGPS Project 中可以找到一个名为 MyGPSApp 的 targettarget 'MyGPSApp' do  project 'FastGPS'  ...end</code></pre><p><strong>inhibit_all_warnings</strong>!：禁止所有警告。</p><p>如果针对单个 Pod，则可以采用：</p><pre><code class="ruby">pod 'SSZipArchive', :inhibit_warnings =&gt; truepod 'SSZipArchive', :inhibit_warnings =&gt; true</code></pre><p><strong>user_modular_headers</strong>!：将所有 Pod 模块化。</p><p>如果针对单个 Pod，则可以采用：</p><pre><code class="ruby">pod 'SSZipArchive', :modular_headers =&gt; truepod 'SSZipArchive', :modular_headers =&gt; false</code></pre><p><strong>user_frameworks</strong>!：采用 framework 而不是 .a 文件的静态库。</p><p>可以通过 <code>:linkage</code> 指定使用静态库还是动态库：</p><pre><code class="ruby">use_frameworks！:linkage =&gt; :dynamic / :static</code></pre><p><strong>supports_swift_versions</strong>：指定 target definition 支持的 swift 版本要求</p><pre><code class="ruby">supports_swift_versions '&gt;= 3.0', '&lt; 4.0'</code></pre><h3 id="Workspace"><a href="#Workspace" class="headerlink" title="Workspace"></a>Workspace</h3><p><strong>workspace</strong>：指定包含所有项目的 Xcode workspace。</p><pre><code class="ruby">workspace 'MyWorkspace'</code></pre><h3 id="Sources"><a href="#Sources" class="headerlink" title="Sources"></a>Sources</h3><p><strong>sources</strong>：Podfile 从指定的源列表中进行检索。sources 默认存储在 ~/.cocoapods/repos 中，是全局的而非按 target definition 存储。当有多个相同的 Pod 时，优先采用检索到的 Pod 的第一个源，因此当指定另一个来源时，则需显示指定 CocoaPods 的源。</p><pre><code class="ruby">source 'https://github.com/artsy/Specs.git'source 'https://github.com/CocoaPods/Specs.git'</code></pre><h3 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h3><p><strong>plugin</strong>：指定在安装期间使用的插件。</p><pre><code class="ruby">plugin 'cocoapods-keys', :keyring =&gt; 'Eidolon'plugin 'slather'</code></pre><p><strong>pre_install</strong>：在下载后和在安装 Pod 前进行更改。</p><pre><code class="ruby">pre_install do |installer|  # Do something fancy!end</code></pre><p><strong>pre_integrate</strong>：在 project 写入磁盘前进行更改。</p><pre><code class="ruby">pre_integrate do |installer|  # perform some changes on dependenciesend</code></pre><p><strong>post_install</strong>：对生成 project 写入磁盘前进行最后的修改。</p><pre><code class="ruby">post_install do |installer|  installer.pods_project.targets.each do |target|    target.build_configurations.each do |config|      config.build_settings['GCC_ENABLE_OBJC_GC'] = 'supported'    end  endend</code></pre><p><strong>post_integrate</strong>：在 project 写入磁盘后进行最后更改。</p><pre><code class="ruby">post_integrate do |installer|  # some change after project write to diskend</code></pre><h2 id="podspec-语法规范"><a href="#podspec-语法规范" class="headerlink" title="podspec 语法规范"></a>podspec 语法规范</h2><p>podspec = pod Specification，意为 pod 规范，它是一个 Ruby 文件。包含了 Pod 的库版本详细信息，例如应从何处获取源、使用哪些文件、要应用构建设置等信息；也可以看作该文件是整个仓库的索引文件，了解它对我们知道 Pod 库是如何组织、运作的提供了很大帮助。podspec 的 DSL 提供了极大的灵活性，文件可通过 <code>pod spec create</code> 创建。</p><h3 id="Root"><a href="#Root" class="headerlink" title="Root"></a>Root</h3><table><thead><tr><th>名称</th><th>用途</th><th>必需</th></tr></thead><tbody><tr><td><code>name</code></td><td>pod 名称</td><td>required</td></tr><tr><td><code>version</code></td><td>pod 版本，遵循语义化版本控制</td><td>required</td></tr><tr><td><code>swift_version</code></td><td>支持的 Swift 版本</td><td></td></tr><tr><td><code>cocoapods_version</code></td><td>支持的 CocoaPods 版本</td><td></td></tr><tr><td><code>authors</code></td><td>pod 维护者的姓名和电子邮件，用“, ”进行分割</td><td>required</td></tr><tr><td><code>license</code></td><td>pod 的许可证</td><td>required</td></tr><tr><td><code>homepage</code></td><td>pod 主页的 URL</td><td>required</td></tr><tr><td><code>source</code></td><td>源地址，即源文件的存放地址，支持多种形式源</td><td>required</td></tr><tr><td><code>summary</code></td><td>pod 的简短描述</td><td>required</td></tr><tr><td><code>prepare_command</code></td><td>下载 pod 后执行的 bash 脚本</td><td></td></tr><tr><td><code>static_framework</code></td><td>是否采用静态 framework 分发</td><td></td></tr><tr><td><code>deprecated</code></td><td>该库是否已被弃用</td><td></td></tr><tr><td><code>deprecated_in_favor_of</code></td><td>该库名称已被弃用，取而代之</td><td></td></tr></tbody></table><pre><code class="ruby">Pod::Spec.new do |s|  s.name             = 'CustomPod'  s.version          = '0.1.0'  s.summary          = 'A short description of CustomPod.'  s.swift_versions   = ['3.0', '4.0', '4.2']  s.cocoapods_version  =  '&gt;= 0.36'  s.author           = { 'nihao' =&gt; 'XXXX@qq.com' }  s.license          = { :type =&gt; 'MIT', :file =&gt; 'LICENSE' }  s.homepage         = 'https://github.com/XXX/CustomPod'# Supported Key# :git=&gt; :tag, :branch, :commit,:submodules# :svn=&gt; :folder, :tag,:revision# :hg=&gt;:revision# :http=&gt; :flatten, :type, :sha256, :sha1,:headers  s.source           = { :git =&gt; 'https://github.com/XX/CustomPod.git', :tag =&gt; s.version.to_s }  s.prepare_command  =  'ruby build_files.rb'  s.static_framework = true  s.deprecated       = true  s.deprecated_in_favor_of  =  'NewMoreAwesomePod'end</code></pre><h3 id="Platform"><a href="#Platform" class="headerlink" title="Platform"></a>Platform</h3><p><strong>platform</strong>：pod 支持的平台，留空意味着 pod 支持所有平台。当支持多平台时应该用 <code>deployment_target</code> 代替。</p><pre><code class="ruby">spec.platform = :osx, '10.8'</code></pre><p><strong>deployment_target</strong>：允许指定支持此 pod 的多个平台，为每个平台指定不同的部署目标。</p><pre><code class="ruby">spec.ios.deployment_target = '6.0'spec.osx.deployment_target = '10.8'</code></pre><h3 id="Build-settings"><a href="#Build-settings" class="headerlink" title="Build settings"></a>Build settings</h3><p><strong>dependency</strong>：基于其他 pods 或子规范的依赖</p><pre><code class="ruby">spec.dependency 'AFNetworking', '~&gt; 1.0', :configurations =&gt; ['Debug']</code></pre><p><strong>info_plist</strong>：加入到生成的 Info.plist 的键值对，会对 CocoaPods 生成的默认值进行覆盖。仅对使用 framework 的框架有影响，对静态库无效。对于应用规范，这些值将合并到应用程序主机的 <code>Info.plist</code>；对于测试规范，这些值将合并到测试包的 Info.plist。</p><pre><code class="ruby">spec.info_plist = {  'CFBundleIdentifier' =&gt; 'com.myorg.MyLib',  'MY_VAR' =&gt; 'SOME_VALUE'}</code></pre><p><strong>requires_arc</strong>：允许指定哪些 source_files 采用 ARC，不使用 ARC 的文件将具有 <code>-fno-objc-arc</code> 编译器标志</p><pre><code class="ruby">spec.requires_arc = falsespec.requires_arc = 'Classes/Arc'spec.requires_arc = ['Classes/*ARC.m', 'Classes/ARC.mm']</code></pre><p><strong>frameworks</strong>：使用者 target 需要链接的系统框架列表</p><pre><code class="ruby">spec.ios.framework = 'CFNetwork'spec.frameworks = 'QuartzCore', 'CoreData'</code></pre><p><strong>weak_frameworks</strong>：使用者 target 需要弱链接的框架列表</p><pre><code class="swift">spec.weak_framework = 'Twitter'spec.weak_frameworks = 'Twitter', 'SafariServices'</code></pre><p><strong>libraries</strong>：使用者 target 需要链接的系统库列表</p><pre><code class="ruby">spec.ios.library = 'xml2'spec.libraries = 'xml2', 'z'</code></pre><p><strong>compiler_flags</strong>：应传递给编译器的 flags</p><pre><code class="ruby">spec.compiler_flags = '-DOS_OBJECT_USE_OBJC=0', '-Wno-format'</code></pre><p><strong>pod_target_xcconfig</strong>：将指定 flag 添加到最终 pod 的 xcconfig 文件</p><pre><code class="ruby">spec.pod_target_xcconfig = { 'OTHER_LDFLAGS' =&gt; '-lObjC' }</code></pre><p><strong>user_target_xcconfig</strong>：🙅 将指定 flag 添加到最终聚合的 target 的 xcconfig，不推荐使用此属性，因为会污染用户的构建设置，可能会导致冲突。</p><pre><code class="ruby">spec.user_target_xcconfig = { 'MY_SUBSPEC' =&gt; 'YES' }</code></pre><p><strong>prefix_header_contents</strong>：🙅 在 Pod 中注入的预编译内容，不推荐使用此属性，因为其会污染用户或者其他库的预编译头。</p><pre><code class="ruby">spec.prefix_header_contents = '#import &lt;UIKit/UIKit.h&gt;', '#import &lt;Foundation/Foundation.h&gt;'</code></pre><p><strong>prefix_header_file</strong>：预编译头文件，false 表示不生成默认的 CocoaPods 的与编译头文件。🙅 不推荐使用路径形式，因为其会污染用户或者其他库的预编译头。</p><pre><code class="ruby">spec.prefix_header_file = 'iphone/include/prefix.pch'spec.prefix_header_file = false</code></pre><p><strong>module_name</strong>：生成的 framrwork / clang module 使用的名称，而非默认名称。</p><pre><code class="ruby">spec.module_name = 'Three20'</code></pre><p><strong>header_dir</strong>：存储头文件的目录，这样它们就不会被破坏。</p><pre><code class="ruby">spec.header_dir = 'Three20Core'</code></pre><p><strong>header_mappings_dir</strong>：用于保留头文件文件夹的目录。如未提供，头文件将被碾平。</p><pre><code class="ruby">spec.header_mappings_dir = 'src/include'</code></pre><p><strong>script_phases</strong>：该属性允许定义脚本在 pod 编译时执行，其作为 <code>xcode build</code> 命令的一部分执行，还可以利用编译期间所设置的环境变量。</p><pre><code class="ruby">spec.script_phases = [    { :name =&gt; 'Hello World', :script =&gt; 'echo "Hello World"' },    { :name =&gt; 'Hello Ruby World', :script =&gt; 'puts "Hello World"', :shell_path =&gt; '/usr/bin/ruby' },  ]</code></pre><h3 id="File-patterns"><a href="#File-patterns" class="headerlink" title="File patterns"></a>File patterns</h3><p>文件模式指定了库的所有文件管理方式，如源代码、头文件、framework、libaries、以及各种资源。其文件模式通配符形式可参考 <a href="https://guides.cocoapods.org/syntax/podspec.html#group_file_patterns">LINK</a>。</p><p><strong>source_files</strong>：指定源文件</p><pre><code class="ruby">spec.source_files = 'Classes/**/*.{h,m}', 'More_Classes/**/*.{h,m}'</code></pre><p><strong>public_header_files</strong>：指定公共头文件，这些头文件与源文件匹配，并生成文档向用户提供。如果未指定，则将 source_files 中的所有头文件都包含生成。</p><pre><code class="ruby">spec.public_header_files = 'Headers/Public/*.h'</code></pre><p><strong>project_header_files</strong>：指定项目头文件，与公共头文件相对应，以排除不应向用户项目公开且不应用于生成文档的标头，且不会出现在构建目录中。</p><pre><code class="ruby">spec.project_header_files = 'Headers/Project/*.h'</code></pre><p><strong>private_header_files</strong>：私有头文件，与公共头文件对应，以排除不应向用户项目公开且不应用于生成文档的标头，这些头文件会出现在产物中的 PrivateHeader 文件夹中。</p><pre><code class="ruby">spec.private_header_files = 'Headers/Private/*.h'</code></pre><p><strong>vendered_frameworks</strong>：pod 附加的 framework 路径</p><pre><code class="ruby">spec.ios.vendored_frameworks = 'Frameworks/MyFramework.framework'spec.vendored_frameworks = 'MyFramework.framework', 'TheirFramework.xcframework'    </code></pre><p><strong>vendered_libraries</strong>：pod 附加的 libraries 路径</p><pre><code class="ruby">spec.ios.vendored_library = 'Libraries/libProj4.a'spec.vendored_libraries = 'libProj4.a', 'libJavaScriptCore.a'</code></pre><p><strong>on_demand_resources</strong>：根据 <a href="https://developer.apple.com/videos/play/wwdc2015/214/">Introducing On demand Resources</a> 按需加载资源，不推荐与主工程共享标签，默认类别为 <code>category =&gt; :download_on_demand</code></p><pre><code class="ruby">s.on_demand_resources = {  'Tag1' =&gt; { :paths =&gt; ['file1.png', 'file2.png'], :category =&gt; :download_on_demand }}s.on_demand_resources = {  'Tag1' =&gt; { :paths =&gt; ['file1.png', 'file2.png'], :category =&gt; :initial_install }}</code></pre><p><strong>resources</strong>：为 pod 构建的 bundle 的名称和资源文件，其中 key 为 bundle 名称，值代表它们应用的文件模式。</p><pre><code class="ruby">spec.resource_bundles = {    'MapBox' =&gt; ['MapView/Map/Resources/*.png'],    'MapBoxOtherResources' =&gt; ['MapView/Map/OtherResources/*.png']}</code></pre><p><strong>exclude_files</strong>：排除的文件模式列表</p><pre><code class="ruby">spec.ios.exclude_files = 'Classes/osx'spec.exclude_files = 'Classes/**/unused.{h,m}'</code></pre><p><strong>preserve_paths</strong>：下载后不应删除的文件。默认情况下，CocoaPods 会删除与其他文件模式不匹配的所有文件</p><pre><code class="ruby">spec.preserve_path = 'IMPORTANT.txt'spec.preserve_paths = 'Frameworks/*.framework'</code></pre><p><strong>module_map</strong>：pod 继承为 framework 时使用的模块映射文件，默认为 true，CocoaPods 根据 公共头文件创建 module_map 文件。</p><pre><code class="ruby">spec.module_map = 'source/module.modulemap'spec.module_map = false</code></pre><h3 id="Subspecs"><a href="#Subspecs" class="headerlink" title="Subspecs"></a>Subspecs</h3><p><strong>subspec</strong>：子模块的规范；实行双重继承：specs 自动继承所有 subspec 作为依赖项(除非指定默认 spec)；subspec 继承了父级的属性；</p><pre><code class="ruby"># 采用不同源文件的 Specs, CocoaPods 自动处理重复引用问题subspec 'Twitter' do |sp|  sp.source_files = 'Classes/Twitter'endsubspec 'Pinboard' do |sp|  sp.source_files = 'Classes/Pinboard'end# 引用其他子规范s.subspec "Core" do |ss|    ss.source_files  = "Sources/Moya/", "Sources/Moya/Plugins/"    ss.dependency "Alamofire", "~&gt; 5.0"    ss.framework  = "Foundation"  end  s.subspec "ReactiveSwift" do |ss|    ss.source_files = "Sources/ReactiveMoya/"    ss.dependency "Moya/Core"    ss.dependency "ReactiveSwift", "~&gt; 6.0"  end  s.subspec "RxSwift" do |ss|    ss.source_files = "Sources/RxMoya/"    ss.dependency "Moya/Core"    ss.dependency "RxSwift", "~&gt; 5.0"  endend# 嵌套子规范Pod::Spec.new do |s|  s.name = 'Root'  s.subspec 'Level_1' do |sp|    sp.subspec 'Level_2' do |ssp|    end  endend</code></pre><p><strong>default_subspecs</strong>：默认子规范数组名称，不指定将全部子规范作为默认子规范，<code>:none</code> 表示不需要任何子规范。</p><pre><code class="ruby">spec.default_subspec = 'Core'spec.default_subspecs = 'Core', 'UI'spec.default_subspecs = :none    </code></pre><p><strong>scheme</strong>：用以给指定 scheme configuration 添加拓展</p><pre><code class="ruby">spec.scheme = { :launch_arguments =&gt; ['Arg1'] }spec.scheme = { :launch_arguments =&gt; ['Arg1', 'Arg2'], :environment_variables =&gt; { 'Key1' =&gt; 'Val1'} }</code></pre><p><strong>test_spec</strong>：测试规范，在 1.8 版本支持。可参考：<a href="https://blog.cocoapods.org/CocoaPods-1.8.0-beta/">CocoaPods 1.8 Beta</a></p><p><strong>requires_app_host</strong>：是否需要宿主 APP 运行测试，仅适用于测试规范。</p><p><strong>app_host_name</strong>：必要时作用于应用程序的应用程序规范名称</p><p><strong>app_spec</strong>：宿主 APP 规范</p><pre><code class="ruby">Pod::Spec.new do |s|  s.name         = 'CannonPodder'  s.version      = '1.0.0'  # ...rest of attributes here  s.app_spec 'DemoApp' do |app_spec|    app_spec.source_files = 'DemoApp/**/*.swift'    # Dependency used only by this app spec.    app_spec.dependency 'Alamofire'  end  s.test_spec 'Tests' do |test_spec|    test_spec.requires_app_host = true    # Use 'DemoApp' as the app host.    test_spec.app_host_name = 'CannonPodder/DemoApp'    # ...rest of attributes here    # This is required since 'DemoApp' is specified as the app host.    test_spec.dependency 'CannonPodder/DemoApp'  endend</code></pre><h3 id="Multi-Platform-support"><a href="#Multi-Platform-support" class="headerlink" title="Multi-Platform support"></a>Multi-Platform support</h3><p>存储特定于某一个平台的值，分别为 ios、osx、macOS、tvos、watchos：</p><pre><code class="ruby">spec.resources = 'Resources/**/*.png'spec.ios.resources = 'Resources_ios/**/*.png'</code></pre><h2 id="Pod-的开发流程"><a href="#Pod-的开发流程" class="headerlink" title="Pod 的开发流程"></a>Pod 的开发流程</h2><p>了解完 Podfile 和 podspec 的相关的规范之后，那么开发自己的 pod 应该是一件驾轻就熟的事。</p><h3 id="Spec-Repo"><a href="#Spec-Repo" class="headerlink" title="Spec Repo"></a>Spec Repo</h3><p>Spec Repo 是 podspec 的仓库，即是存储相关的 podspec 文件的地方。本地源存储于 ~/.cocoapods/repos中，它从 git 上拉取并完全保留目录结构。可以发现， Master Specs Repo 的现在目录结构有些特殊；以往版本的 Master Spec Repo 是完全在同一目录下的，但若大量文件在同一目录中会导致了 <a href="https://github.com/CocoaPods/CocoaPods/issues/4989#issuecomment-193772935">Github 下载慢</a> 的问题。为解决这个问题，采用散列表形式处理。具体方式为对名称进行 MD5 计算得到散列值，取前三位作为目录前缀，以对文件分散化。初次之外，CocoaPods 后续还采用 CDN 以及 trunk 进一步加快下载速度，有兴趣可以参考 <a href="http://chuquan.me/2022/01/07/source-analyze-principle/">CocoaPods Source 管理机制</a>。</p><p>如：<code>md5("CJFoundation") =&gt; 044d913fdd5a52b303222c357521f744</code>；<code>CJFoundation</code> 则在 /Specs/0/4/4 目录中</p><p><img src="https://raw.githubusercontent.com/xuhaodong1/resource/master/image-20221215171557476.png" alt="image-20221215171557476"></p><h3 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h3><p>只需利用  <code>pod lib create [PodName]</code> 命令便可以快速创建一个自己的 pod 。填写好使用平台、使用语言、是否包含 Demo、测试框架等信息，CocoaPods 会从默认的 Git 地址中拉取一份 pod 模版，同时也可以通过 <code>--template-url=URL</code> 指定模版地址。在执行完后，整个文件结构如下：</p><pre><code class="swift">tree CustomPod -L 2CustomPod├── CustomPod│   ├── Assets // 存放资源文件│   └── Classes│       └── RemoveMe.[swift/m] // 单一文件以确保最初编译工作├── CustomPod.podspec // Pod 的 spec 文件, 是一个 Pod 依赖的索引以及规范信息├── Example // 用作演示/测试的示例项目│   ├── CustomPod│   ├── CustomPod.xcodeproj│   ├── CustomPod.xcworkspace│   ├── Podfile│   ├── Podfile.lock│   ├── Pods│   └── Tests├── _Pods.xcodeproj -&gt; Example/Pods/Pods.xcodeproj // 指向 Pods 项目的以获得 Carthage 支持├── LICENSE // 许可证└── README.md  // 自述文件</code></pre><h3 id="Development"><a href="#Development" class="headerlink" title="Development"></a>Development</h3><p>将源文件和资源分别放入 Classes / Assets 文件夹中，或者按你喜欢的方式组织文件，并在 podspec 文件中编辑相应项。如果你有任何想使用的配置项，可参考前面的podsepc 语法规范 。</p><p>一般来说，开发 Pod 一般都是作为本地 Pod 被其他 Project 所依赖进行开发，无论是使用 example 文件夹的 project 或者其他的 Project。</p><p><code>pod 'Name', :path =&gt; '~/CustomPod/'</code></p><h3 id="Testing"><a href="#Testing" class="headerlink" title="Testing"></a>Testing</h3><p>通过 <code>pod lib lint</code> 以验证 Pod 仓库的使用是否正常。</p><h3 id="Release"><a href="#Release" class="headerlink" title="Release"></a>Release</h3><p>前面提到过 podspec 可以看作是整个仓库的索引文件，有了这个文件也就能组织起一个 Pod。因此官方的源以及私有源都只需要 podspec 即可，而其他文件则应推送到 podspec 中 source 中指定仓库，这个仓库应该是你自创建的。</p><p>在准备发布推送源代码时，需要更新版本号以及在 git 上打上 tag，这是为了进行版本号匹配，因为默认情况下的 podspec 文件中：</p><pre><code class="ruby">s.source = { :git =&gt; 'https://github.com/XXX/CustomPod.git', :tag =&gt; s.version.to_s }</code></pre><p>可能你的工作流操作如下：</p><pre><code class="shell">$ cd ~/code/Pods/NAME$ edit NAME.podspec# set the new version to 0.0.1# set the new tag to 0.0.1$ pod lib lint$ git add -A &amp;&amp; git commit -m "Release 0.0.1."$ git tag '0.0.1'$ git push --tags</code></pre><p>存有几种方式推送 podspec 文件：</p><ol><li>推送到<a href="https://github.com/CocoaPods/Specs.git">公共仓库</a>，需要用到的 trunk 子命令，更多可以参考 <a href="https://guides.cocoapods.org/making/getting-setup-with-trunk">Getting setup with Trunk</a>：</li></ol><pre><code class="shell"># 通过电子邮箱进行注册pod trunk register orta@cocoapods.org 'Orta Therox' --description='macbook air' # 将指定podspec文件推送到公共仓库中pod trunk push [NAME.podspec] # 添加其他人作为协作者pod trunk add-owner ARAnalytics kyle@cocoapods.org </code></pre><ol start="2"><li>推送到私有源，例如 <a href="https://github.com/artsy/Specs">Artsy/Specs</a>，需要用到 repo 子命令，更多可以参考 <a href="https://guides.cocoapods.org/making/private-cocoapods">Private Pods</a>：</li></ol><pre><code class="shell"># 将私有源地址添加到本地pod repo add REPO_NAME SOURCE_URL # 检查私有源是否安装成功并准备就绪cd ~/.cocoapods/repos/REPO_NAMEpod repo lint .# 将Pod的podspec添加到指定REPO_NAME中pod repo push REPO_NAME SPEC_NAME.podspec</code></pre><ol start="3"><li>不推送到任何源中，若能存在以 URL 方式检索到 podspec文件，则可用该 URL，一般采用仓库地址，例如：</li></ol><pre><code class="ruby">pod 'AFNetworking', :git =&gt; 'https://github.com/XXX/CustomPod.git'</code></pre><h3 id="Semantic-Versioning"><a href="#Semantic-Versioning" class="headerlink" title="Semantic Versioning"></a>Semantic Versioning</h3><p>语义化版本控制顾名思义是一种语义上的版本控制，它不要求强制遵循，只是希望开发者能够尽量遵守。如果库之间依赖关系过高，可能面临版本控制被锁死的风险（可能需要对每一个依赖库改版才能完成某次升级）；如果库之间依赖关系过于松散，又将无法避免版本的混乱（可能库兼容性不再能支持以往版本），语义化版本控制正是作为这个问题的解决方案之一。无论在 CocoaPods 中，还是 Swift Packager Manager 上，官方都希望库开发者的的版本号能遵循这一原则：</p><p>例如，给定版本号 <code>MAJOR.MINOR.PATCH</code>：</p><ol><li><code>MAJOR</code>：进行不兼容的 API 更改时进行修改</li><li><code>MINOR</code>：向后兼容的方式添加新功能时进行修改</li><li><code>PATCH</code>：进行向后兼容的错误修复时进行修改</li></ol><p>先行版本号以及版本编译信息可以添加到 <code>MAJOR.MINOR.PATCH</code> 后面以作为延伸。</p><h2 id="CocoaPods-原理浅析"><a href="#CocoaPods-原理浅析" class="headerlink" title="CocoaPods 原理浅析"></a>CocoaPods 原理浅析</h2><h3 id="CococaPods-核心组件"><a href="#CococaPods-核心组件" class="headerlink" title="CococaPods 核心组件"></a>CococaPods 核心组件</h3><p>CocoaPods 被 Ruby 管理，其核心部分也被分为一个一个组件。下载源码，可以看到 Gemfile 文件如下，其依赖了若干个 gem，有意思的是 <code>cp_gem</code> 函数，通过 <code>SKIP_UNRELEASED_VERSIONS</code> 与 <code>path</code> 来控制是否采用本地的 gem 路径，实现了 DEVELOPMENT 与 RELEASE 环境的切换。</p><pre><code class="ruby">SKIP_UNRELEASED_VERSIONS = false# Declares a dependency to the git repo of CocoaPods gem. This declaration is# compatible with the local git repos feature of Bundler.def cp_gem(name, repo_name, branch = 'master', path: false)  return gem name if SKIP_UNRELEASED_VERSIONS  opts = if path           { :path =&gt; "../#{repo_name}" }         else           url = "https://github.com/CocoaPods/#{repo_name}.git"           { :git =&gt; url, :branch =&gt; branch }         end  gem name, optsendsource 'https://rubygems.org'gemspecgroup :development do  cp_gem 'claide',                'CLAide'  cp_gem 'cocoapods-core',        'Core'  cp_gem 'cocoapods-deintegrate', 'cocoapods-deintegrate'  cp_gem 'cocoapods-downloader',  'cocoapods-downloader'  cp_gem 'cocoapods-plugins',     'cocoapods-plugins'  cp_gem 'cocoapods-search',      'cocoapods-search'  cp_gem 'cocoapods-trunk',       'cocoapods-trunk'  cp_gem 'cocoapods-try',         'cocoapods-try'  cp_gem 'molinillo',             'Molinillo'  cp_gem 'nanaimo',               'Nanaimo'  cp_gem 'xcodeproj',             'Xcodeproj'  gem 'cocoapods-dependencies', '~&gt; 1.0.beta.1'  ...end</code></pre><p>这些组件相对独立，被分成一个一个 Gem 包，在 <a href="https://guides.cocoapods.org/contributing/components.html">Core Components</a> 中，可以找到对这些组件的简要描述。同时也可以到 CocoaPods 的 Github 中去看详细文档。</p><img src="https://raw.githubusercontent.com/xuhaodong1/resource/master/image-20221216104815073.png" style="zoom:40%;"><ul><li><strong>CocoaPods</strong>：命令行支持与安装程序，也会处理 CocoaPods 的所有用户交互。</li><li><strong>cocoapods-core</strong>：对模版文件的解析，如 Podfile、.podspec 等文件。</li><li><strong>CLAide</strong>：一个简单的命令解析器，它提供了一个快速创建功能齐全的命令行界面的 API。</li><li><strong>cocoapods-downloader</strong>：用于下载源码，为各种类型的源代码控制器(HTTP/SVN/Git/Mercurial) 提供下载器。它提供 tags、commites、revisions、branches 以及 zips 文件的下载与解压缩操作。</li><li><strong>Monlinillo：CocoaPods</strong>：对于依赖仲裁算法的封装，它是一个具有前项检察的回溯算法。不仅在 pods 中，Bundler 和 RubyGems 也是使用这一套仲裁算法。</li><li><strong>Xcodeproj</strong>：通过 Ruby 来对 Xcode projects 进行创建于修改。如：脚本管理、libraries 构建、Xcode workspece 和配置文件的管理。</li><li><strong>cocoapods-plugins</strong>：插件管理，其中有 pod plugins 命令帮助你获取的可用插件列表以及开发一个新插件等功能，具体可用 <code>pod plugins --help</code> 了解。</li></ul><h3 id="pod-install-做了什么"><a href="#pod-install-做了什么" class="headerlink" title="pod install 做了什么"></a>pod install 做了什么</h3><p>执行 <code>pod install --verbose</code>，会显示 pod install 过程中的更多 debugging 信息。下文主要参考：<a href="https://www.desgard.com/2020/08/17/cocoapods-story-2.html">整体把握 CocoaPods 核心组件</a></p><p>经过消息转发与 CLAide 命令解析，最终调用了 CocoaPods/lib/cocoapods/installer.rb 的 install! 函数，主要流程图如下：</p><img src="https://raw.githubusercontent.com/xuhaodong1/resource/master/image-20221216145652667.png" style="zoom:45%;"><pre><code class="ruby">def install!    prepare    resolve_dependencies    download_dependencies    validate_targets    clean_sandbox    if installation_options.skip_pods_project_generation?        show_skip_pods_project_generation_message        run_podfile_post_install_hooks    else    integrate    end    write_lockfiles    perform_post_install_actionsend</code></pre><h4 id="1-Install-环境准备（prepare）"><a href="#1-Install-环境准备（prepare）" class="headerlink" title="1. Install 环境准备（prepare）"></a>1. Install 环境准备（prepare）</h4><pre><code class="ruby">def prepare  # 如果检测出当前目录是 Pods，直接 raise 终止  if Dir.pwd.start_with?(sandbox.root.to_path)    message = 'Command should be run from a directory outside Pods directory.'    message &lt;&lt; "\n\n\tCurrent directory is #{UI.path(Pathname.pwd)}\n"    raise Informative, message  end  UI.message 'Preparing' do    # 如果 lock 文件的 CocoaPods 主版本和当前版本不同，将以新版本的配置对 xcodeproj 工程文件进行更新    deintegrate_if_different_major_version    # 对 sandbox(Pods) 目录建立子目录结构    sandbox.prepare    # 检测 PluginManager 是否有 pre-install 的 plugin    ensure_plugins_are_installed!    # 执行插件中 pre-install 的所有 hooks 方法    run_plugins_pre_install_hooks  endend</code></pre><p>在 prepare 阶段会完成 <code>pod install</code> 的环境准备，包括目录结构、版本一致性以及 <code>pre_install</code> 的 hook。</p><h4 id="2-解决依赖冲突（resolve-dependencies）"><a href="#2-解决依赖冲突（resolve-dependencies）" class="headerlink" title="2. 解决依赖冲突（resolve dependencies）"></a>2. 解决依赖冲突（resolve dependencies）</h4><pre><code class="ruby">def resolve_dependencies    # 获取 Sources    plugin_sources = run_source_provider_hooks    # 创建一个 Analyzer    analyzer = create_analyzer(plugin_sources)    # 如果带有 repo_update 标记    UI.section 'Updating local specs repositories' do        # 执行 Analyzer 的更新 Repo 操作        analyzer.update_repositories    end if repo_update?    UI.section 'Analyzing dependencies' do        # 从 analyzer 取出最新的分析结果，@analysis_result，@aggregate_targets，@pod_targets        analyze(analyzer)        # 拼写错误降级识别，白名单过滤        validate_build_configurations    end    # 如果 deployment? 为 true，会验证 podfile &amp; lockfile 是否需要更新    UI.section 'Verifying no changes' do        verify_no_podfile_changes!        verify_no_lockfile_changes!    end if deployment?    analyzerend</code></pre><p>通过 Podfile、Podfile.lock 以及 manifest.lock 等生成 Analyzer 对象，其内部会使用个 Molinillo 算法解析得到一张依赖关系表，进行一系列的分析与依赖冲突解决。</p><h4 id="3-下载依赖文件（download-dependencies）"><a href="#3-下载依赖文件（download-dependencies）" class="headerlink" title="3. 下载依赖文件（download dependencies）"></a>3. 下载依赖文件（download dependencies）</h4><pre><code class="ruby">def download_dependencies  UI.section 'Downloading dependencies' do    # 构造 Pod Source Installer    install_pod_sources    # 执行 podfile 定义的 pre install 的 hooks    run_podfile_pre_install_hooks    # 根据配置清理 pod sources 信息，主要是清理无用 platform 相关内容    clean_pod_sources  endend</code></pre><p>​    经过前面分析与解决依赖冲突后，这是会进行依赖下载。会根据依赖信息是否被新添加或者修改等信息进行下载，同时下载后也会在本地留有一份缓存，其目录在 ～/Library/Caches/CocoaPods 。</p><h4 id="4-验证-targets（validate-targets）"><a href="#4-验证-targets（validate-targets）" class="headerlink" title="4. 验证 targets（validate targets）"></a>4. 验证 targets（validate targets）</h4><pre><code class="ruby">def validate_targets    validator = Xcode::TargetValidator.new(aggregate_targets, pod_targets, installation_options)    validator.validate!enddef validate!    verify_no_duplicate_framework_and_library_names    verify_no_static_framework_transitive_dependencies    verify_swift_pods_swift_version    verify_swift_pods_have_module_dependencies    verify_no_multiple_project_names if installation_options.generate_multiple_pod_projects?end</code></pre><p><strong>verify_no_duplicate_framework_and_library_names</strong>：验证是否有重名的 framework / library</p><p><strong>verify_no_static_framework_transitive_dependencies</strong>：验证动态库是否有静态链接库依赖。个人认为，这个验证是不必要的，起码不必要 error。</p><p><strong>verify_swift_pods_swift_version</strong>：验证 Swift pod 的 Swift 版本配置且相互兼容</p><p><strong>verify_swift_pods_have_module_dependencies</strong>：验证 Swift pod 是否支持 module</p><p><strong>verify_no_multiple_project_names</strong>：验证没有重名的 project 名称</p><h4 id="5-生成工程（Integrate）"><a href="#5-生成工程（Integrate）" class="headerlink" title="5. 生成工程（Integrate）"></a>5. 生成工程（Integrate）</h4><pre><code class="ruby">def integrate    generate_pods_project    if installation_options.integrate_targets?        # 集成用户配置，读取依赖项，使用 xcconfig 来配置        integrate_user_project    else        UI.section 'Skipping User Project Integration'    endenddef generate_pods_project    # 创建 stage sanbox 用于保存安装前的沙盒状态，以支持增量编译的对比    stage_sandbox(sandbox, pod_targets)    # 检查是否支持增量编译，如果支持将返回 cache result    cache_analysis_result = analyze_project_cache    # 需要重新生成的 target    pod_targets_to_generate = cache_analysis_result.pod_targets_to_generate    # 需要重新生成的 aggregate target    aggregate_targets_to_generate = cache_analysis_result.aggregate_targets_to_generate    # 清理需要重新生成 target 的 header 和 pod folders    clean_sandbox(pod_targets_to_generate)    # 生成 Pod Project，组装 sandbox 中所有 Pod 的 path、build setting、源文件引用、静态库文件、资源文件等    create_and_save_projects(pod_targets_to_generate, aggregate_targets_to_generate,                                cache_analysis_result.build_configurations, cache_analysis_result.project_object_version)    # SandboxDirCleaner 用于清理增量 pod 安装中的无用 headers、target support files 目录    SandboxDirCleaner.new(sandbox, pod_targets, aggregate_targets).clean!    # 更新安装后的 cache 结果到目录 `Pods/.project_cache` 下    update_project_cache(cache_analysis_result, target_installation_results)end</code></pre><p>将之前版本仲裁的所有组件通过 project 文件的形式组织起来，并对 project 中做一些用户指定的配置。</p><h4 id="6-写入依赖（write-lockfiles）"><a href="#6-写入依赖（write-lockfiles）" class="headerlink" title="6. 写入依赖（write lockfiles）"></a>6. 写入依赖（write lockfiles）</h4><pre><code class="ruby">def write_lockfiles  @lockfile = generate_lockfile  UI.message "- Writing Lockfile in #{UI.path config.lockfile_path}" do    # No need to invoke Sandbox#update_changed_file here since this logic already handles checking if the    # contents of the file are the same.    @lockfile.write_to_disk(config.lockfile_path)  end  UI.message "- Writing Manifest in #{UI.path sandbox.manifest_path}" do    # No need to invoke Sandbox#update_changed_file here since this logic already handles checking if the    # contents of the file are the same.    @lockfile.write_to_disk(sandbox.manifest_path)  endend</code></pre><p>将依赖更新写入 Podfile.lock 与 Manifest.lock</p><h4 id="7-结束回调（perform-post-install-action）"><a href="#7-结束回调（perform-post-install-action）" class="headerlink" title="7. 结束回调（perform post install action）"></a>7. 结束回调（perform post install action）</h4><pre><code class="ruby">def perform_post_install_actions  # 调用 HooksManager 执行每个插件的 post_install 方法   run_plugins_post_install_hooks  # 打印过期 pod target 警告  warn_for_deprecations  # 如果 pod 配置了 script phases 脚本，会主动输出一条提示消息  warn_for_installed_script_phases  # 警告移除的 master specs repo 的 specs  warn_for_removing_git_master_specs_repo  # 输出结束信息 `Pod installation complete!`  print_post_install_messageend</code></pre><p>最后的收尾工作，进行 <code>post install action</code> 的 hook 执行以及一些 warning 打印。</p><h2 id="CocoaPods-Plugins"><a href="#CocoaPods-Plugins" class="headerlink" title="CocoaPods + Plugins"></a>CocoaPods + Plugins</h2><p>早在 2013 年，CocoaPods 就添加了对插件的支持，以添加不符合依赖管理和生态系统增长为主要目标的功能。CocoaPods Plugins 可以：在 install 前后添加 hook、添加新命令到 pod、以及利用 Ruby 动态性做任何事。下面介绍一下常见的插件：</p><ul><li><p><a href="https://github.com/leavez/cocoapods-binary">cocoapods-binary</a>：一个比较早期的二进制插件库，是诸多二进制方案的灵感来源</p></li><li><p><a href="https://github.com/wordpress-mobile/cocoapods-repo-update">cocoapods-repo-update</a>：自动化 pod repo update</p></li><li><p><a href="https://github.com/upgrad/cocoapods-integrate-flutter">cocoapods-integrate-flutter</a>：将 flutter 与现有 iOS 应用程序集成</p></li><li><p><a href="https://github.com/alibaba/cocoapods-uploader">cocoapods-uploader</a>：上传文件/目录到远程仓库</p></li></ul><p>ps：许多插件可能许久未维护，读者使用需自行斟酌。</p><h2 id="不太常见概念"><a href="#不太常见概念" class="headerlink" title="不太常见概念"></a>不太常见概念</h2><p>CocoaPods 的配置内容几乎包含了 Xcode Build 的方方面面，因此存在许多不太常见的概念，在此做一个链接聚合以供参考。</p><ul><li>Clang Module / module_map / umbrella header：Clang Module 是 Clang 16.0.0 中引入的概念，用以解决 #include / #import 头文件引入导致的相关问题；module_map 是用以描述 clang module 与 header 的关系；umbrella header 则是 module_map 中的语法规范，表示指定目录中的头文件都应包含在模块中。</li></ul><p><a href="https://clang.llvm.org/docs/Modules.html#introduction">Modules</a></p><p><a href="http://chuquan.me/2021/02/11/clang-module/">Clang Module</a></p><p><a href="https://www.stephenw.cc/2017/08/23/llvm-modules/">LLVM 中的 Module</a></p><ul><li>Hmap / Xcode Header / CocoaPods Headers</li></ul><p>Header Map 是一组头文件信息映射表，用 .hmap 后缀表示，整体结构以 Key-Value 形式存储；Key为头文件名称、Value 为 头文件物理地址。</p><p>Xcode Phases - Header 在构建配置中分为 public、private 与 project ，用以与 target 关联；其中 public 、private 就复制到最终产物的 header 和 PrivateHeaders 中，而 project 头文件不对外使用，则不会放到最终产物。</p><p><a href="https://tech.meituan.com/2021/02/25/cocoapods-hmap-prebuilt.html">一款可以让大型iOS工程编译速度提升50%的工具</a></p><p><a href="https://help.apple.com/xcode/mac/current/#/dev50bab713d">What are build phases?</a></p><ul><li>Xcconfig：</li></ul><p>一种配置文件，用以对构建设置进行声明与管理，比如区分不同的开发环境等。</p><p><a href="https://nshipster.com/xcconfig/">Xcode Build Configuration Files</a></p><ul><li>On demand resource：WWDC 2015 引入的概念，对资源文件的按需加载。</li></ul><p><a href="https://developer.apple.com/videos/play/wwdc2015/214/">Introducing On Demand Resources</a></p><h2 id="🔗："><a href="#🔗：" class="headerlink" title="🔗："></a>🔗：</h2><p>[1] <a href="https://cocoapods.org/">Cocoapods.org</a></p><p>[2] <a href="https://medium.com/orion-innovation-turkey/xcode-workspace-with-multiple-projects-1b42f5182c45">Xcode Workspace with multiple projects</a></p><p>[3] <a href="https://objccn.io/issue-6-4/">深入理解 CocoaPods</a></p><p>[4] <a href="http://chuquan.me/2021/02/14/understand-ios-library-and-framework/">系统理解 iOS 库与框架</a></p><p>[5] <a href="https://swiftunwrap.com/article/cocoapods-script-phases/">Cocoapods script phases</a></p><p>[6] <a href="http://chuquan.me/2021/12/24/podfile-analyze-principle/">CocoaPods Podfile 解析原理</a></p><p>[7] <a href="https://semver.org/">Semantic Versioning 2.0.0</a></p><p>[8] <a href="https://tech.meituan.com/2021/02/25/cocoapods-hmap-prebuilt.html">一款可以让大型iOS工程编译速度提升50%的工具</a></p><p>[9] <a href="http://chuquan.me/2022/01/07/source-analyze-principle/#more">CocoaPods Source 管理机制</a></p><p>[10] <a href="https://www.desgard.com/2020/06/11/cocoapods-story-1.html#podfilelock">版本管理工具及 Ruby 工具链环境</a></p><p>[11] <a href="https://www.desgard.com/2020/08/17/cocoapods-story-2.html">整体把握 CocoaPods 核心组件</a></p><p>[12] <a href="https://binlogo.github.io/post/gong-cheng-xiao-lu-you-hua-cocoapods-you-hua/">工程效率优化：CocoaPods优化</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;对于大多数软件开发团队来说，依赖管理工具必不可少，它能针对开源和私有依赖进行安装与管理，从而提升开发效率，降低维护成本。针对不同的语言与平台，其依赖管理工具也各有不同，例如 npm 管理 Javascript、Gradle 、Maven 管理 Jar 包、pip 管理 Python 包，Bundler、RubyGems 等等。本文聚焦于 iOS 方面，对 CocoaPods 的使用和部分原理进行阐述。&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://xuhaodong1.github.io/categories/iOS/"/>
    
    
    <category term="CocoaPods" scheme="https://xuhaodong1.github.io/tags/CocoaPods/"/>
    
  </entry>
  
  <entry>
    <title>iOS中的事件以及事件传递机制</title>
    <link href="https://xuhaodong1.github.io/2022/07/08/iOS%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BB%A5%E5%8F%8A%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6/"/>
    <id>https://xuhaodong1.github.io/2022/07/08/iOS%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BB%A5%E5%8F%8A%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6/</id>
    <published>2022-07-08T01:49:00.000Z</published>
    <updated>2023-07-20T06:20:30.212Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>iOS 中有 8 种事件，本文重点介绍触摸事件的传递机制与响应流程。可以带着以下问题阅读：</p><ul><li>iOS 中有哪些事件类型，谁来进行事件的响应，怎么来响应呢？</li><li>触摸事件的传递与响应流程</li><li><code>hitTest</code> 方法的作用，它有什么实践场景？</li><li><code>UIControl</code> 与 <code>UIGestureRecognizer</code> 也能响应触摸事件，<code>UIResponder</code> 的响应方式有什么不同？<span id="more"></span></li></ul><h2 id="响应者-amp-响应者链"><a href="#响应者-amp-响应者链" class="headerlink" title="响应者 &amp; 响应者链"></a>响应者 &amp; 响应者链</h2><ul><li>响应者即 <code>UIResponder class</code> 的一个实例；</li><li>响应者链为响应者组成的一个链式结构，不同的链式结构组合起来看起来像一个倒过来的树形结构。</li><li><code>UIResponder</code> 中包含了许多处理事件的方法，如果我们想在这个对象里响应事件，那么重写这个方法即可。</li></ul><img src="/images/blog/responderChain.png" alt="A flow diagram: On the left, a sample app contains a label (UILabel), a text field for the user to input text (UITextField), and a button (UIButton) to  press after entering text in the field. On the right, the flow diagram shows how, after the user pressed the button, the event moves through the responder chain—from UIView, to UIViewController, to UIWindow, UIApplication, and finally to UIApplicationDelegate." style="zoom:67%;"><ul><li><strong>UIView</strong>：如果 <code>view</code> 是 <code>UIViewController</code> 的 <code>root view</code>，下一个响应者为 <code>UIViewController</code>，否则下一个响应者为<code>superview</code>。</li><li><strong>UIViewController</strong>：如果 <code>UIViewController</code> 的 <code>view</code> 是 <code>UIWindow</code> 的 <code>root view</code> 下一个响应者对象是 <code>window</code>；如果 当前 <code>UIViewController</code> 由另一个 <code>UIViewController push</code> 或者 <code>presented</code>，则下一个响应者为 弹出该 <code>vc</code> 的 <code>UIViewController</code>，例如 <code>UINavigationController</code>、<code>UITableBarController</code>。</li><li><strong>UIWindow</strong>：下一个响应者为 <code>UIApplication</code></li><li><strong>UIApplication</strong>：下一个响应者为 <code>UIApplicationDelegate</code>，前提是它不是 <code>UIView</code>、<code>UIViewController</code>、以及不是 <code>UIApplication</code> 本身。一般来说，是指 <code>AppDelegate</code>。</li></ul><h2 id="事件-amp-谁是事件的第一响应者"><a href="#事件-amp-谁是事件的第一响应者" class="headerlink" title="事件 &amp; 谁是事件的第一响应者"></a>事件 &amp; 谁是事件的第一响应者</h2><table><thead><tr><th>事件类型</th><th>第一响应者</th></tr></thead><tbody><tr><td>触摸事件 touch events</td><td>发生触摸的视图</td></tr><tr><td>按压事件 press events</td><td>被聚焦的对象</td></tr><tr><td>摇动事件 shake-motion events</td><td>你(or UIKit)指定的对象</td></tr><tr><td>远程控制事件 remote-control event</td><td>你(or UIKit)指定的对象</td></tr><tr><td>编辑菜单消息 editing menu messages</td><td>你(or UIKit)指定的对象</td></tr><tr><td>加速器 accelerometers</td><td>委任的对象</td></tr><tr><td>陀螺 gyroscopes</td><td>委任的对象</td></tr><tr><td>磁力仪 magnetometer</td><td>委任的对象</td></tr></tbody></table><p>在 iOS 中，有 8 种类型的事件，响应这些事件的对象被称为响应者，系统的一些常见的响应者为 <code>UIView</code>、<code>UIViewController</code>、<code>UIWindow</code>、<code>UIAppllication</code>、<code>AppDelegate</code>，在找到最佳响应者后，如果事件没有被处理，事件会随着响应者链进行传递。不过有些事件在进行传递的时候，即使重写了响应事件的方法，特定对象不会进行响应，例如 <code>shake-motion events</code> 不会由 <code>UIView</code>、<code>UIApplication</code>、<code>AppDelegate</code> 进行响应。</p><ul><li>触摸事件 <code>touch events</code>，是 iOS 中最常见的事件，每一次触碰都会由 IOKit 通过 IPC 交给 SpringBoard，进而通过 <code>mach port</code> 传递给合适的进程进行响应，第一响应者是发生触碰的视图，后面会重点讲解。</li></ul><pre><code class="swift">open func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?)open func touchesMoved(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?)open func touchesEnded(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?)open func touchesCancelled(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?)@available(iOS 9.1, *)open func touchesEstimatedPropertiesUpdated(_ touches: Set&lt;UITouch&gt;)</code></pre><ul><li>按压事件<code>press events</code>，表示如遥控器或者游戏手柄中进行按压触碰而产生的事件，由当前聚焦的对象进行响应。</li></ul><pre><code class="swift">@available(iOS 9.0, *)open func pressesBegan(_ presses: Set&lt;UIPress&gt;, with event: UIPressesEvent?)@available(iOS 9.0, *)open func pressesChanged(_ presses: Set&lt;UIPress&gt;, with event: UIPressesEvent?)@available(iOS 9.0, *)open func pressesEnded(_ presses: Set&lt;UIPress&gt;, with event: UIPressesEvent?)@available(iOS 9.0, *)open func pressesCancelled(_ presses: Set&lt;UIPress&gt;, with event: UIPressesEvent?)</code></pre><ul><li>摇动事件 <code>shake-motion events</code>，晃动设备进行触发。</li></ul><pre><code class="swift">open func motionBegan(_ motion: UIEvent.EventSubtype, with event: UIEvent?)open func motionEnded(_ motion: UIEvent.EventSubtype, with event: UIEvent?) open func motionCancelled(_ motion: UIEvent.EventSubtype, with event: UIEvent?)</code></pre><ul><li>远程控制事件 <code>remote-control event</code>，在音视频播放时，锁屏界面或者控制中心中点击 “上一个”、“下一个”、“暂停”和“继续”等操作时触发的事件。</li></ul><pre><code class="swift">@available(iOS 4.0, *)open func remoteControlReceived(with event: UIEvent?)</code></pre><ul><li>编辑菜单消息 <code>editing menu messages</code>，编辑文本出现的菜单列表产生的事件。</li></ul><pre><code class="swift">open func buildMenu(with builder: UIMenuBuilder)@available(iOS 13.0, *)open func validate(_ command: UICommand)@available(iOS 3.0, *)open var undoManager: UndoManager? { get }@available(iOS 13.0, *)open var editingInteractionConfiguration: UIEditingInteractionConfiguration { get }</code></pre><ul><li>加速器事件、陀螺事件、磁力仪事件不跟随响应者链，<code>Core Motion</code> 将这些事件直接传递给指定的委任对象。</li></ul><h2 id="触摸事件流程"><a href="#触摸事件流程" class="headerlink" title="触摸事件流程"></a>触摸事件流程</h2><img src="/images/blog/image-20220620215940554.png" alt="image-20220620215940554" style="zoom:80%;"><p>当触摸事件发生时，被用户面板即硬件由电信号采集到，之后再传递给 <code>IOKit.framework</code>，并将事件封装为 <code>IOHIDEvent</code>；之后通过 IPC 转发给 <code>SpringBoard</code> 进程；再由 <code>SpringBoard</code> 进程再次通过 <code>IPC</code> 将事件传递给合适的 APP 进程；由主线程 <code>RunLoop</code> 进行处理，先触发 <code>source1</code> 回调，后触发了 <code>source0</code> 回调，并将事件封装为 <code>UIEvent</code>；然后将事件加入 <code>UIApplication</code> 对象的事件队列中，出队后，开始寻找最佳响应者 <code>hit-Testing</code>，找到最佳响应者后。由 <code>UIApplication</code> 对象 从 <code>sendEvent</code> 方法将事件传递给 <code>window</code> 对象，再由 <code>window</code> 对象 <code>sendEvent</code> 到最佳响应者，随后进行事件响应以及传递。寻找最佳响应者以及事件响应后面会重点提及，这里先简单对 IOKit.framework、SpringBoard 以及 IPC 进行简单介绍：</p><ul><li>IOKit.framework：它为设备驱动程序(IOKit)的用户态组件，IOKit 来源于 NeXTSTEP 的 DriverKit，IOKit.framework 提供了内核态以及用户态双向通信的接口。</li><li>SpringBoard：iOS 中的 SpringBoard 相当于 macOS 中的 Finder，它向用户提供了熟悉的图标界面，它记录了多触摸事件、加速器事件、按压事件等。</li><li>IPC：macOS 和 iOS 中的进程间通信(InterProcess Communication) 是基于 mach，mach 是 iOS 和 macOS 中的核心，也是有别于其他操作系统的重点，mach 采用微内核的概念，即内核仅提供一些必要的功能，其他工作由用户态实现。mach 的 IPC 是通过在两个端口之间发送消息实现，具体可以参考 《深入解析Mac OS X &amp; iOS 操作系统》。</li></ul><h3 id="寻找最佳响应者"><a href="#寻找最佳响应者" class="headerlink" title="寻找最佳响应者"></a>寻找最佳响应者</h3><ol><li>由 <code>UIApplication</code> 传递给 <code>UIWindow</code>，如果有多个 <code>UIWindow</code> 对象，则按倒序进行查询。</li><li>对于每一个 <code>UIWindow</code>、<code>UIView</code> 对象来说，也是倒叙查询其子视图和本视图能否响应。</li></ol><p>如果从遍历方式来看，是一个反过来的 <code>dfs</code>。倒叙是因为如果有视图重叠，在上方的是后加入的对象；具体来说都是通过 <code>UIView</code> 的 <code>hitTest</code> 方法进行判断是不是最佳响应者，如果存在则返回该 <code>UIView</code>，不存在则返回 <code>nil</code>。</p><ul><li><code>hitTest(_ point: CGPoint, with event: UIEvent?)</code> <strong>模拟代码</strong></li></ul><pre><code class="swift">override func hitTest(_ point: CGPoint, with event: UIEvent?) -&gt; UIView? {    guard self.isUserInteractionEnabled &amp;&amp; !self.isHidden &amp;&amp; self.alpha &gt; 0.01 else {        return nil    }    if self.point(inside: point, with: event) {        for subview in subviews.reversed() {            let convertedPoint = subview.convert(point, from: self)            let hitTestView = subview.hitTest(convertedPoint, with: event)            if let hitTestView = hitTestView {                return hitTestView            }        }      return self    }    return nil}</code></pre><ol><li><p>需要 <code>isUserInteractionEnabled</code> 为 <code>true</code>、<code>isHidden</code> 为 <code>fasle</code> 且透明度 &gt; 0.01</p></li><li><p>如果命中点在视图内，尝试倒序遍历子视图，查找是否有更合适的点，若有则返回子视图的 <code>hitTest()</code>，若无则返回本视图(<code>self</code>)。</p></li><li><p>如果命中点不在视图内，则返回 <code>nil</code>。</p></li></ol><ul><li><code>point(inside point: CGPoint, with event: UIEvent?)</code> <strong>模拟代码</strong></li></ul><pre><code class="swift">override func point(inside point: CGPoint, with event: UIEvent?) -&gt; Bool {    return bounds.contains(point)}</code></pre><ol><li>判断当前 bounds 是否包含该点。</li></ol><h3 id="触摸事件的响应以及传递"><a href="#触摸事件的响应以及传递" class="headerlink" title="触摸事件的响应以及传递"></a>触摸事件的响应以及传递</h3><p>找到最佳响应者后，<code>UIApplication</code> 对象 <code>sendEvent</code> 到响应该视图的 <code>UIWindow</code>，再有 <code>UIWindow</code> 对象 <code>sendEvent</code> 到最佳响应者，这一点可以通过查看调用栈帧看出：</p><img src="/images/blog/image-20220704022615988.png" alt="image-20220704022615988" style="zoom:100%;"><p>传递给最佳响应者后，便可以进行事件的响应了，对于触摸事件来说，调用上述提到的 5 个方法即代表响应。事件的拦截是通过 <code>open func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?)</code> 实现的，传递方式与规则见上文中 <strong>响应者 &amp; 响应者链</strong>：</p><ul><li>不重写，默认将事件交给响应者链传递</li><li>重写不掉用 <code>super.touchesBegan(touches, with: event)</code>，事件由该响应者处理，不进行传递</li><li>重写并调用 <code>super.touchesBegan(touches, with: event)</code>，将事件交给响应者链传递</li></ul><p>采用 <code>touchesBegan</code> 等系列方法以响应算是比较底层的方式，为快速响应各种类型的触摸事件，Apple 提供了 <code>UIGestureRecognizer</code> 与 <code>UIControl</code> 这两种方式。</p><h4 id="UIGestureRecognizer"><a href="#UIGestureRecognizer" class="headerlink" title="UIGestureRecognizer"></a>UIGestureRecognizer</h4><p>UIGestureRecognizer 手势识别器是处理视图中的触摸和按压事件的最好方式，如果我们仅用触摸事件基本响应方式进行处理的话，难度较大且不现实。它是一个基类，Apple 提供了 8 种手势，同时也可以创建自定义手势。</p><ul><li><code>UITapGestureRecognizer</code>：轻点手势</li><li><code>UIPinchGestureRecognizer</code>：捏合手势</li><li><code>UIRotationGestureRecognizer</code>：旋转手势</li><li><code>UISwipeGestureRecognizer</code>：滑动手势</li><li><code>UIPanGestureRecognizer</code>：拖拽手势</li><li><code>UIScreenEdgePanGestureRecognizer</code>：屏幕边缘拖拽手势</li><li><code>UILongPressGestureRecognizer</code>：长按手势</li><li><code>UIHoverGestureRecognizer</code>：指针悬停（macOS &amp; iPadOS）</li></ul><p>手势识别器分为离散型和持续性两种：</p><p>离散型手势在识别到手势后只调用一次 <code>action</code> 方法，其变化过程为：</p><ul><li><p>识别成功：Possible —&gt; Recognized</p></li><li><p>识别失败：Possible —&gt; Failed</p></li></ul><p>持续性手势在满足最初始识别条件后，会在手势信息变化中多次调用 action 方法，其变化过程为：</p><ul><li><p>完整识别：Possible —&gt; Began —&gt; [Changed] —&gt; Ended</p></li><li><p>不完整识别：Possible —&gt; Began —&gt; [Changed] —&gt; Cancel</p></li></ul><p><strong>对于 UIResponder 的触摸响应优先级来说，UIGestureRecognizer 的响应优先级会更高一点</strong>；在 hit-Testing 过程中，就会判断当前 <code>view</code> 的手势识别器是否符合条件，符合条件的手势识别器对象会保存在 <code>UIEvent</code> 中，并在 <code>sendEvent</code> 时首先发送给它，如果手势识别器识别成功，则默认会取消剩余的触摸响应事件，表现为调用 <code>touchesCancelled</code> 方法。</p><p>三个重要的属性会改变上述过程：</p><ul><li><code>cancelsTouchesInView</code>：默认为 true，表示在识别手势成功后，是否取消剩余的触摸响应事件；</li><li><code>delaysTouchesBegan</code>：默认为 false，表示是否在识别手势失败后，才将触摸事件传递给 <code>hit-Tested view</code>；</li><li><code>delaysTouchesEnded</code>：默认为 true，表示是否在识别手势失败后，才将 <code>touchesEnded</code> 事件发送给 <code>hit-Tested view</code>；</li></ul><p>手势冲突</p><p>手势默认是互斥的，但可以利用 <code>UIGestureRecognizerDelegate</code> 进行手势优先级处理。</p><h4 id="UIControl"><a href="#UIControl" class="headerlink" title="UIControl"></a>UIControl</h4><p>UIControl 是响应特定动作或意图的视觉元素的控件基类，它是 <code>UIView</code> 的子类，因此它也是响应者对象；<code>UIButton</code>、<code>UISwitch</code>、<code>UISlider</code> 等都是它的子类，也可以自定义 <code>UIControl</code>。通过  <code>addTarget(_:action:for:)</code> 指定响应事件和对象和方法，如果 <code>target</code> 为 <code>nil</code>，则按照响应链传递该事件。</p><pre><code class="swift">open func beginTracking(_ touch: UITouch, with event: UIEvent?) -&gt; Boolopen func continueTracking(_ touch: UITouch, with event: UIEvent?) -&gt; Boolopen func endTracking(_ touch: UITouch?, with event: UIEvent?) // touch is sometimes nil if cancelTracking calls through to this.open func cancelTracking(with event: UIEvent?) // event may be nil if cancelled for non-event reasons, e.g. removed from window</code></pre><p>与 <code>UIResponder</code> 类似，<code>UIControl</code> 有 4 种跟踪触摸事件的方法，分别与 <code>UIResponder</code> 的 <code>began</code>、<code>moved</code>、<code>ended</code>、<code>cancelled</code> 相对应。如果查看其调用栈，可以发现在 <code>UIResponder</code> 方法内部调用了 <code>UIControl</code> 的跟踪方法。</p><p><img src="/images/blog/image-20220707113956921.png" alt="image-20220707113956921"></p><p>如果在响应事件的方法打断点，查看调用栈帧，会发现 <code>UIControl</code> 会首先将事件通过 <code>sendAction:to:forEvent:</code> 发送给 <code>UIApplication</code>，再通过 <code>sendAction</code> 转发给发送的对象的对象。</p><p><img src="/images/blog/image-20220707114606464.png" alt="image-20220707114606464"></p><p>与 <code>UIGestureRecognizer</code> 相比，事件仍会优先传递到 <code>UIGestureRecognizer</code>，这一点可以重写 <code>UIGestureRecognizer</code> 的 4 个响应方法验证。</p><p>如果 <code>UIControl</code> 是其子视图，会判断其是否为系统默认控件，系统默认控件则优先响应 <code>UIControl</code> 的 <code>action</code> 方法，如果为自定义控件，则默认优先响应 <code>UIGestureRecognizer</code> 的 <code>action</code>。值得注意的是，如果将 <code>UIGestureRecognizer</code> 的 <code>cancelsTouchesInView</code> 改为<code> false</code>(默认为 <code>true</code>)，则发现 <code>UIGestureRecognizer</code> 也会进行响应，个人理解为 <code>cancelsTouchesInView</code> 改变了响应互斥的特性，因此本身也会响应。 </p><p>如果 <code>UIControl</code> 为父视图或平级视图，由于仍会优先将事件传递到 <code>UIGestureRecognizer</code>， 则可以根据其 <code>cancelsTouchesInView</code>、<code>delaysTouchesBegan</code>、<code>delaysTouchesEnded</code> 判断事件能否传递到 <code>UIControl</code>，这一点 <code>UIControl</code> 与 <code>UIResponder</code> 一致。</p><h3 id="应用实践"><a href="#应用实践" class="headerlink" title="应用实践"></a>应用实践</h3><h4 id="扩大响应区域"><a href="#扩大响应区域" class="headerlink" title="扩大响应区域"></a>扩大响应区域</h4><ol><li>重写本视图的 <code>func point(inside point: CGPoint, with event: UIEvent?) -&gt; Bool</code> </li></ol><pre><code class="swift">override func point(inside point: CGPoint, with event: UIEvent?) -&gt; Bool {    // 将响应区域扩大 30    return self.bounds.inset(by: .init(top: -30, left: -30, bottom: -30, right: -30)).contains(point)}</code></pre><ol start="2"><li>重写父视图的 <code>func hitTest(_ point: CGPoint, with event: UIEvent?) -&gt; UIView?</code></li></ol><pre><code class="swift">override func hitTest(_ point: CGPoint, with event: UIEvent?) -&gt; UIView? {    // 将响应区域扩大 30    // subView 为应扩大响应区域的视图    if subView.frame.inset(by: .init(top: -30, left: -30, bottom: -30, right: -30)).contains(point) {        return subView    }    return super.hitTest(point, with: event)}</code></pre><h4 id="根据触摸实时修改-view-位置"><a href="#根据触摸实时修改-view-位置" class="headerlink" title="根据触摸实时修改 view 位置"></a>根据触摸实时修改 view 位置</h4><pre><code class="swift">override func touchesMoved(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) {    let touch = touches.randomElement()    let prePoint = touch?.precisePreviousLocation(in: self)    let currPoint = touch?.location(in: self)    if let prePoint = prePoint, let currPoint = currPoint {        let offsetX = currPoint.x - prePoint.x        let offsetY = currPoint.y - prePoint.y        self.transform = self.transform.translatedBy(x: offsetX, y: offsetY)    }}</code></pre><h2 id="🔗"><a href="#🔗" class="headerlink" title="🔗"></a>🔗</h2><p><a href="https://developer.apple.com/documentation/uikit/touches_presses_and_gestures/using_responders_and_the_responder_chain_to_handle_events">Using Responders and the Responder Chain to Handle Events</a></p><p><a href="https://www.jianshu.com/p/c294d1bd963d">iOS 触摸事件全家桶</a></p><p><a href="https://developer.apple.com/documentation/uikit/uigesturerecognizer?language=objc">Apple - UIGestureRecognizer</a></p><p><a href="http://southpeak.github.io/2015/12/13/cocoa-uikit-uicontrol/">UIKit: UIControl</a></p><p>《深入解析Mac OS X &amp; iOS 操作系统》</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;iOS 中有 8 种事件，本文重点介绍触摸事件的传递机制与响应流程。可以带着以下问题阅读：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;iOS 中有哪些事件类型，谁来进行事件的响应，怎么来响应呢？&lt;/li&gt;
&lt;li&gt;触摸事件的传递与响应流程&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hitTest&lt;/code&gt; 方法的作用，它有什么实践场景？&lt;/li&gt;
&lt;li&gt;&lt;code&gt;UIControl&lt;/code&gt; 与 &lt;code&gt;UIGestureRecognizer&lt;/code&gt; 也能响应触摸事件，&lt;code&gt;UIResponder&lt;/code&gt; 的响应方式有什么不同？&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://xuhaodong1.github.io/categories/iOS/"/>
    
    
    <category term="UI" scheme="https://xuhaodong1.github.io/tags/UI/"/>
    
  </entry>
  
  <entry>
    <title>Xcode 中的调试技巧</title>
    <link href="https://xuhaodong1.github.io/2022/06/01/debugging_in_xcode/"/>
    <id>https://xuhaodong1.github.io/2022/06/01/debugging_in_xcode/</id>
    <published>2022-06-01T01:49:00.000Z</published>
    <updated>2022-12-20T13:01:35.264Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Xcode</code> 内置了许多工具能够帮助开发者进行高效快速的 <code>Debug</code>，例如 <code>LLDB</code>、 <code>Instruments</code>、<code>Debug View Hierarchy</code>、<code>Debug Memory Graph</code> 等。本文将介绍 <code>LLDB</code> 中实用的命令，以及如何利用 <code>Instruments</code> 解决内存相关的问题。 <span id="more"></span></p><h2 id="LLDB"><a href="#LLDB" class="headerlink" title="LLDB"></a>LLDB</h2><p><code>LLDB</code> 是 <code>LLVM</code> 中的调试器组件，支持调试 <code>C</code>、<code>Objective-C</code>、<code>C++</code> 编写的程序，<code>Swift</code> 社区维护了一个版本，增加了对该语言的支持，<code>LLDB</code> 是 <code>Xcode</code> 的默认调试器。对于熟练使用 <code>Xcode</code> 的开发者来说，创建断点、使断点无效是一件再简单不过的事情，只需要的源代码的左侧行数点击即可。但是在 <code>LLDB</code> 还有许多提升开发效率的事，例如 <code>frame、breakpoint</code>、<code>expression</code>、<code>image</code> 等命令。</p><h3 id="expression"><a href="#expression" class="headerlink" title="expression"></a>expression</h3><p><code>expression</code> 主要用于「在当前线程执行表达式，并显示其返回值」。其语法如下：<br><code>expression &lt;cmd-options&gt; -- &lt;expr&gt;</code><br>例如被大家所熟知的 <code>po</code>、<code>p</code> 都是关于 <code>expression</code> 的缩写形式</p><ul><li>  <code>po</code> 是 <code>expression -O --</code> 的缩写形式</li><li>  <code>p</code> 是 <code>expression --</code> 的缩写形式<br>可以看到，主要有可选参数与表达式两部分；为了区分可选参数与表达式，采用 <code>--</code> 进行分割，下面列举常用的一些可选参数：</li><li>  <code>-D</code>，设置最大递归深度解析层级</li><li>  <code>-O</code>，打印特定语言的对象的 <code>description</code> 方法</li><li>  <code>-T</code>，显示变量类型</li><li>  <code>-f</code>，以特定格式化类型进行输出</li><li>  <code>-i</code>，执行表达式时忽略断点触发<br>更多的可选参数可以通过 <code>help expression</code> 进行查看<br>同时，<code>expression</code> 还可以可以定义变量，但需在变量名前面加入 <code>$</code> 标识符，例如</li></ul><p>在 <code>Swift</code> 中：</p><p><code>expression var width: CGFloat = 20.0</code></p><p>在 <code>OC</code> 中：</p><p><code>expression NSArray *$array = @[@"one", @"two"];</code></p><h3 id="进程流程控制"><a href="#进程流程控制" class="headerlink" title="进程流程控制"></a>进程流程控制</h3><img src="/images/blog/image-20220420112717291.png" alt="image-20220420112717291" style="zoom:200%;"><p>当程序运行或暂停时，在控制台上方会出现上图这 4 个按钮，这 4 个按钮分别对应着「进程暂停与继续」、「执行当前行」、「调入执行函数」、「跳出执行函数」，分别对应着以下 4 个命令：</p><ol><li> <code>process continue(continue)</code></li><li> <code>thread step-over(next、n)</code></li><li> <code>thread step in(step、s)</code></li><li> <code>thread step out(fin)</code></li></ol><p>断点对于调试来说是很重要的东西，只需要在 <code>Xcode</code> 源文件左侧点击即可添加断点，同时也会出现在 <code>Breakpoint navigator</code> 中：</p><img src="/images/blog/image-20220511110055321.png" alt="image-20220511110055321" style="zoom:50%;"><p>同时还可以添加列断点，如果你的一行代码中有几个表达式，你可能希望只停留在某一个表达式中，那么列断点就很有用了，右键想要断点的表达式，点击 <code>Create Column Breakpoint</code> 即可创建列断点。</p><img src="/images/blog/image-20220512110941465.png" alt="image-20220512110941465" style="zoom:67%;"><p>在 <code>Breakpoint navigator</code> 中点击左下角的 <code>+</code> 号，可以发现创建有 6 大类型的断点，不过主要来说可以分为两种：</p><ul><li>  异常、错误断点：捕获异常和错误，在将要发生 <code>Crash</code> 时，提前暂停并定位到有错误的代码中。</li><li>  符号断点：即 <code>Symbolic Breakpoint</code>，可以通过方法名称创建断点，当执行到对应的方法时，便会暂停。</li></ul><img src="/images/blog/image-20220512111557861.png" alt="image-20220512111557861" style="zoom:67%;"><p>还可以使用 <code>breakpoint</code> 命令来进行对断点的管理，下面介绍一些常见的命令：</p><ul><li>  <code>breakpoint list</code> 显示断点列表</li><li>  <code>breakpoint enable / disable / del &lt;breakpointId&gt;</code> 通过 id 开启、关闭、删除断点( <code>id</code> 即为 <code>breakpoint list</code> 显示的 <code>id</code> )</li><li>  <code>breakpoint set &lt;cmd-options&gt;</code></li></ul><p>创建断点的方式有很多种，但最常见的是通过文件名与代码行数创建，或者是符号化进行创建：</p><ul><li>  <code>breakpoint set -f &lt;fileName&gt; -l &lt;lineNum&gt;</code> 通过文件名与代码行数创建</li><li>  <code>breakpoint set -n &lt;function_name&gt;</code> 通过方法名创建</li></ul><p>同时还可以在 <code>Breakpoint navigator</code> 中对断点进行编辑，给断点创建名称、断点触发执行条件、暂停前忽略次数、执行 <code>Action</code>，以及执行完 <code>Action</code> 后继续执行。</p><img src="/images/blog/image-20220518170038329.png" alt="image-20220518170038329" style="zoom:67%;"><p>不过上述的功能都可以通过命令行实现，例如创建执行 <code>Action</code> 与 断点触发执行条件如下：</p><p><code>breakpoint set -C &lt;command&gt; -c &lt;condition expression&gt; -n &lt;function_name&gt;</code></p><p>更多功能可通过 <code>help breakpoint</code> 进行查看。</p><p>如果想观察某个值发生变化，那么 <code>watchpoint</code> 会非常有用，同样创建 <code>watchpoint</code> 有 2 种方式，在 debug 时右键属性并点击 <code>watch "&lt;variable-name&gt;"</code>。</p><img src="/images/blog/image-20220512153529644.png" alt="image-20220512153529644" style="zoom:67%;"><p>控制台则可以 <code>watchpoint set variable [-w &lt;watch-type&gt;] [-s &lt;byte-size&gt;] &lt;variable-name&gt;</code> 进行创建。</p><h2 id="其他常见的命令"><a href="#其他常见的命令" class="headerlink" title="其他常见的命令"></a>其他常见的命令</h2><p><code>frame</code> 命令可以显示当前栈帧的一些信息：</p><ul><li>  <code>frame info</code>：显示栈帧所在位置</li><li>  <code>frame variable &lt;variableName&gt;</code>：显示栈帧变量，如果没有 <code>&lt;variableName&gt;</code> 则显示栈帧的变量列表，别名 v</li></ul><p><code>thread</code> 用于操作当前进程的一个或多个线程</p><ul><li>  <code>thread list</code>：显示所有线程</li><li>  <code>thread info</code>：显示线程的额外概要</li><li>  <code>thread backtrace</code> ：显示线程的调用栈</li><li>  <code>thread continue</code>：继续执行一个或多个指定线程</li><li>  <code>thread exception</code>：显示线程异常对象</li><li>  <code>thread return</code>：提前返回一个栈帧，并可提供可选返回值</li></ul><p><code>process</code> 在当前平台与进程交互</p><ul><li>  <code>process continue</code>：继续执行当前进程中的所有线程</li><li>  <code>process interrupt</code>：中断当前进程</li><li>  <code>process kill</code>：结束当前进程</li><li>  <code>process status</code>：显示当前进程状态</li></ul><p><code>image</code> 可以访问目标模块的信息（是 <code>target modules</code> 的缩写）</p><ul><li>  <code>image list</code>：列出当前可执行和依赖的共享库镜像</li><li>  <code>image lookup</code>：根据参数查找其在可执行和依赖的共享库镜像的信息(如：地址、文件名、方法名、符号等)</li><li>  <code>image search-paths</code>：搜索路径的配置项</li><li>  <code>image show-unwind</code>：显示函数合成的 <code>unwind</code> 指令</li></ul><p><code>disassemble</code> 显示当前 <code>target</code> 中的指定汇编指令，默认是当前线程和当前栈帧中的当前方法</p><ul><li>  <code>disassemble</code>：当前线程和当前栈帧中的当前方法的汇编指令</li><li>  <code>disassemble -a &lt;address-expression&gt;</code>：从某一地址开始</li><li>  <code>disassemble -n &lt;function-name&gt;</code>：从某一方法开始</li></ul><p>最后，还可以利用 <code>commond alias</code> 或者编写 <code>python</code> 脚本来实现自己的 <code>LLDB</code> 命令。</p><h2 id="po-amp-p-amp-v"><a href="#po-amp-p-amp-v" class="headerlink" title="po &amp; p &amp; v"></a>po &amp; p &amp; v</h2><p><code>po</code>、<code>p</code>、<code>v</code> 都可以用来打印变量，那么它们有什么不同呢？</p><ul><li>  <code>po</code> 显示对象的 <code>debugDescription</code> 属性，系统会提供默认值，可以通过实现 <code>CustomDebugStringConvertible</code> 协议进行自定义。</li></ul><p><code>po</code> 后面跟表达式，因此可以执行方法，赋值等操作。<code>po</code> 的执行步骤分为两部分，第一步生成源代码，并在上下文中编译执行，第二步获取第一步返回的对象，并再次生成源代码并在上下文中编译执行，最后显示第二步返回的字符串。这里需要注意的是，为了能够使你的表达式能够被完整表达，<code>LLDB</code> 没有采取直接解析和评估表达式本身，采用生成可编译的源代码进行处理，这种方式完全保留了代码本身。例如，你输入 <code>po view</code>。</p><p>第一步生成的源代码为：</p><pre><code>func __lldb_expr() {     __lldb_res = view}</code></pre><p>第二步生成的源代码为：</p><pre><code>func __lldb_expr2() -&gt; String {    return __lldb_res.debugDescripution}</code></pre><img src="/images/blog/image-20220522170206675.png" alt="image-20220522170206675" style="zoom:67%;"><ul><li>  <code>p</code> 命令，<code>p</code> 与 <code>po</code> 的输出略有不同，但都包含相同的信息，每个表达式结果都会被赋予增值名称，如 <code>$R1</code>、<code>$R2</code> 等，这些结果就会被存储起来，并可以像普通的对象一样使用。<code>p</code> 命令执行分为 3 步，第一步与 <code>po</code> 命令相同，将表达式生成源代码，并进行编译执行，之后会进行动态类型解析，并将解析结果格式化。动态类型解析是由于其多态性，只有在运行时才能得知其运行时类型；对解析结果进行格式化是由于 <code>Swift</code> 标准库即使针对 <code>Int</code>、<code>String</code> 这样的简单类型，都进行了高度封装优化，因此其有复杂表达，所以需要进行格式化。</li></ul><img src="/images/blog/image-20220523174847611.png" alt="image-20220523174847611" style="zoom:35%;"><ul><li>  <code>v</code> 命令，<code>v</code> 命令的输出与 <code>p</code> 完全一样。但与 <code>p</code> 和 <code>po</code> 不同的是，<code>v</code> 命令并不进行编译与执行代码，所以它非常快，它采用点和下标符来访问字段。<code>v</code> 命令执行分为 4 步，首先会查询进程状态为了内存中定位变量，之后便从内存中读取变量，并对其执行动态类型检查，如果它有访问子属性，则多次进行内存读取变量以及动态类型检查。最后将结果进行格式化。</li></ul><img src="/images/blog/image-20220523180303016.png" alt="image-20220523180303016" style="zoom:35%;"><h2 id="Debug-View-Hierarchy"><a href="#Debug-View-Hierarchy" class="headerlink" title="Debug View Hierarchy"></a>Debug View Hierarchy</h2><p>首先从 <code>Xcode</code> 中的 <code>Product -&gt; Scheme -&gt; Edit Scheme -&gt; Diagnostics</code> 中开启 <code>Malloc Stack Logging</code> 选项，并选择 <code>All Allocation and Free History</code>。这开启了创建堆栈信息调用日志，在 Debug 时便可通过对象的信息去查看其调用堆栈。</p><p>打开 <code>Debug View Hierarchy</code>，便可发现在右侧的 <code>Backtrace</code> 中有了内容，如果你有约束冲突，或者想查看某个视图的创建信息，只需要在左侧的图层结构或者中间的图像选中你想要的即可。</p><p><img src="/images/blog/image-20220518192011839.png" alt="image-20220518192011839"></p><p>同样的 <code>LLDB</code> 还给我们带来了更加强大的功能，可以达到不需要重新编译从而改变视图的一些行为，具体实现方法可以类似如下：</p><ol start="0"><li> 定位到某个具体的对象，即从界面中选中某一个视图或者约束。</li><li> 按钮 <code>commond + c</code> 便可复制其带有类型的内存地址，这时便可以对它进行操作，具体的在控制台中，输入你想要改变的操作，如：</li></ol><p><code>e [((UIView *)0x7fa9320061a0) setBackgroundColor: [UIColor greenColor]]</code></p><p>注意这里需要使用 <code>Objective-C</code> 的语法，因为 <code>Swift</code> 的安全性导致不能访问所有内容。</p><ol start="3"><li> 这时你发现界面没有改变，需要刷新视图：</li></ol><p><code>e (void) [CATransaction flush];</code></p><p>具体关于 <code>Debug View Hierarchy</code> 的更多用法可参考<a href="https://www.jianshu.com/p/9800c919e6cc">这里</a>。</p><h2 id="Debug-Memory-Graph"><a href="#Debug-Memory-Graph" class="headerlink" title="Debug Memory Graph"></a>Debug Memory Graph</h2><p>点开 <code>Debug Memory Graph</code>，会暂停进程，并显示当前堆的所有对象，并且会显示它们之间的所属关系和强引用与弱引用（深色的为强引用，浅色的为弱引用）。</p><p>如果你开启了 <code>Malloc Stack Logging</code>，也同样能看见对象的堆栈调用信息。</p><p>不仅如此，还可以发现内存泄漏，可以点开左下角的感叹号，仅筛选出内存泄漏对象。不过令人遗憾的是，<code>Debug Memory Graph</code> 并不能显示出所有的内存泄漏问题。例如下图，在 <code>SecondViewController</code> 持有 <code>block</code> 与 <code>block</code> 中去持有 <code>SecondViewController</code> 中的 <code>view</code>，这是经典的由 <code>block</code> 导致的循环引用，虽然 <code>Debug Memory Graph</code> 没有明确捕捉到，但是仍给我们排查提供了线索。</p><p><img src="/images/blog/image-20220519190816761.png" alt="image-20220519190816761"></p><p>点击 <code>Edit -&gt; Export Memory Graph</code>，可以导出内存分布图文件。利用 <code>vmmap</code>、<code>leaks</code>、<code>heap</code> 等命令行工具可以进一步分析内存问题，具体分析可参考 <a href="http://www.yuezyevil.com/2021/01/14/iOS%20%E5%86%85%E5%AD%98%E8%B0%83%E8%AF%95%E7%AF%87%20%E2%80%94%E2%80%94%20memgraph/">iOS 内存调试篇 – memgraph</a>。</p><h2 id="Instruments"><a href="#Instruments" class="headerlink" title="Instruments"></a>Instruments</h2><p><code>Instruments</code> 提供了一套丰富工具和模版去分析 应用的性能问题，常见的模版有：</p><table><thead><tr><th>名称</th><th>功能</th></tr></thead><tbody><tr><td>Leaks</td><td>一般的查看内存使用情况，检查泄漏的内存，并提供了所有活动的分配和泄漏模块的类对象分配统计信息以及内存地址历史记录。</td></tr><tr><td>Time Profiler</td><td>执行对系统的 CPU上运行的进程低负载时间为基础采样。</td></tr><tr><td>Allocations</td><td>跟踪过程的匿名虚拟内存和堆的对象提供类名和可选保留/释放历史。</td></tr><tr><td>Activity Monitor</td><td>显示器处理的 CPU、内存和网络使用情况统计。</td></tr><tr><td>Blank</td><td>创建一个空的模板，可以从 Library 库中添加其他模板。</td></tr><tr><td>Core Data</td><td>监测读取、缓存未命中、保存等操作，能直观显示是否保存次数远超实际需要。</td></tr><tr><td>Network</td><td>跟踪 TCP/IP 和 UDP/IP 连接。</td></tr><tr><td>Engergy Log</td><td>应用的电量消耗情况。</td></tr></tbody></table><p>下面基于 <code>Time Profiler</code> 模版，梳理如何使用 <code>Instruments</code>：</p><ol start="0"><li> 首先选中 <code>Time Profiler</code>，会出现空的配置页</li><li> 在左上方中选择分析的设备以及应用</li><li> 点击开始，这时便可操作测试你的应用。</li><li> 当操作完成，点击暂停或结束，这时便可针对有问题的数据进行分析。</li></ol><p><img src="/images/blog/image-20220531171357436.png" alt="image-20220531171357436"></p><p>选取你认为可疑的时间段，例如大量占用 <code>CPU</code> 的时间段，其次逐步根据去排查代码问题，例如主线程中有耗时操作。</p><p>更推荐看下 <code>WWDC</code> 中关于 <code>Instruments</code> 的介绍 <a href="https://developer.apple.com/videos/play/wwdc2019/411/">WWDC2019 - Get Started with Instruments</a>，笔者只是简单的概述。关于 <code>Instruments</code>，它没有记录所有的调用栈帧，而是在每秒去记录许多次栈帧快照，这是为了更好的性能体验。</p><h2 id="无限调试"><a href="#无限调试" class="headerlink" title="无限调试"></a>无限调试</h2><p>还有一个关于调试的小技巧，如果你希望不使用数据线连接电脑，可以采用局域网的形式连接，同样也可以进行真机运行与调试。具体在 <code>Device</code> 列表中右键设备并点击 <code>Connect via IP Address</code>。</p><img src="/images/blog/image-20220531144036056.png" alt="image-20220531144036056" style="zoom:67%;"><p>除此之外在菜单栏中选中 <code>Debug</code> 的 <code>Attach to Process by Pid or Name</code> 或者 <code>Attach to Process</code> ，通过列表选中想要附加的进程，就可以不用想要 <code>Debug</code> 的时候再次手动 <code>Run</code> 一次。不过这两种方式，都会有一定性能损耗，会导致响应时间慢问题。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文总结了 <code>LLDB</code> 的一些常见命令，据统计，一名程序员大约有 70% 的时间都在 <code>Debug</code>，如果能够熟练使用它们，无疑会极大提升编程效率。同时还介绍了如 <code>Debug View Hierarchy</code>、<code>Debug Memory Graph</code> 的常见用法。特别是 <code>Debug Memory Graph</code>，因为内存问题往往是不易察觉且不易找到的，好好利用它，能够让我们对内存问题研究的更加深入。最后是 <code>Instruments</code>，它里面有许多工具，针对各方面的性能问题都有所涵盖，<code>Jonathan Levin</code> 称，与其他操作系统相比，<code>Instruments</code> 是最好的调试和性能剖析工具。</p><h2 id="🔗"><a href="#🔗" class="headerlink" title="🔗"></a>🔗</h2><p><a href="https://objccn.io/issue-19-2/">与调试器共舞 - LLDB 的华尔兹</a></p><p><a href="https://medium.com/@vin.pradeilles/advanced-debugging-with-xcode-5e6c8dabd311">用 LLDB 调试 Swift 代码</a></p><p><a href="https://developer.apple.com/videos/play/wwdc2018/412/">WWDC2018 - 412 通过 Xcode 和 LLDB 进行高级调试</a></p><p><a href="https://developer.apple.com/videos/play/wwdc2019/429/">WWDC2019 - 429 LLDB 不限于 “po”</a></p><p><a href="https://developer.apple.com/videos/play/wwdc2019/411/">WWDC2019 - 411 Get Started with Instruments</a></p><p>《深入解析 Mac OS X &amp; iOS 操作系统》</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Xcode&lt;/code&gt; 内置了许多工具能够帮助开发者进行高效快速的 &lt;code&gt;Debug&lt;/code&gt;，例如 &lt;code&gt;LLDB&lt;/code&gt;、 &lt;code&gt;Instruments&lt;/code&gt;、&lt;code&gt;Debug View Hierarchy&lt;/code&gt;、&lt;code&gt;Debug Memory Graph&lt;/code&gt; 等。本文将介绍 &lt;code&gt;LLDB&lt;/code&gt; 中实用的命令，以及如何利用 &lt;code&gt;Instruments&lt;/code&gt; 解决内存相关的问题。&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://xuhaodong1.github.io/categories/iOS/"/>
    
    
    <category term="LLDB" scheme="https://xuhaodong1.github.io/tags/LLDB/"/>
    
    <category term="Instrument" scheme="https://xuhaodong1.github.io/tags/Instrument/"/>
    
  </entry>
  
  <entry>
    <title>iOS中的多线程与线程安全</title>
    <link href="https://xuhaodong1.github.io/2022/04/02/iOS%20%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>https://xuhaodong1.github.io/2022/04/02/iOS%20%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2022-04-02T14:45:00.000Z</published>
    <updated>2022-12-20T13:01:35.265Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 <strong>iOS</strong> 中有 3 种线程管理安全，分别是 <strong>NSThread</strong>、<strong>GCD</strong> 与 <strong>NSOperation</strong>，不包含几乎不直接使用的 <strong>pthread</strong> 。本文就其使用特点以及重要的 <strong>API</strong> ，以及线程安全等方面进行总结。</p><span id="more"></span><h2 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h2><p>轻量级线程操作，面向对象，但需手动管理线程声明周期，同时控制不同线程之间执行顺序不是很友好。</p><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><pre><code class="swift">init(target: Any, selector: Selector, object argument: Any?) // 需要手动 start()init(block: @escaping () -&gt; Void) // 需要手动 start()detachNewThread(_ block: @escaping () -&gt; Void) // 自启动detachNewThreadSelector(_ selector: Selector, toTarget target: Any, with argument: Any?) // 自启动performSelector(inBackground aSelector: Selector, with arg: Any?) // 隐式创建</code></pre><h3 id="线程状态控制"><a href="#线程状态控制" class="headerlink" title="线程状态控制"></a>线程状态控制</h3><pre><code class="swift">start() // 启动sleep(until date: Date) // 休眠到指定时间sleep(forTimeInterval ti: TimeInterval) // 休眠指定时间exit() // 强制立即退出，不管是否执行完毕，可能会导致异常cancel() // 不会立即退出，待到处理完线程上下文后退出，可用 isCancel 监听其是否退出</code></pre><h3 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h3><pre><code class="swift">performSelector(onMainThread aSelector: Selector, with arg: Any?, waitUntilDone wait: Bool, modes array: [String]?) // 到主线程中执行performSelector(onMainThread aSelector: Selector, with arg: Any?, waitUntilDone wait: Bool) // 到主线程中执行perform(_ aSelector: Selector, on thr: Thread, with arg: Any?, waitUntilDone wait: Bool, modes array: [String]?) // 到指定线程中执行perform(_ aSelector: Selector, on thr: Thread, with arg: Any?, waitUntilDone wait: Bool) // 到指定线程中执行</code></pre><h3 id="线程保活"><a href="#线程保活" class="headerlink" title="线程保活"></a>线程保活</h3><pre><code class="swift">let thread = CusThread.init(target: self, selector: #selector(threadAction), object: nil)@objc func threadAction() {    let runLoop = RunLoop.current    runLoop.add(.init(), forMode: .default)    while !Thread.current.isCancelled {        runLoop.run(mode: .default, before: Date.init(timeInterval: 2, since: .now)) // 两秒执行一次        otherAction()    }    }</code></pre><p><strong>runLoop</strong> 需添加 <strong>port</strong> / <strong>timer</strong> 等内容，否则 <strong>runLoop</strong> 会立即退出<br>在需退出时手动调用 <strong>cancel</strong>() 方法，防止 <strong>RunLoop</strong> 持有 <strong>Thread</strong> 导致内存泄露问题</p><h2 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote><p><strong>Grand Central Dispatch（GCD）</strong> 是 Apple 开发的一个多核编程的较新的解决方法。它主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。它是一个在线程池模式的基础上执行的并发任务。在 Mac OS X 10.6 雪豹中首次推出，也可在 iOS 4 及以上版本使用。</p></blockquote><p><strong>GCD</strong> 是 <strong>iOS</strong> 推出的多线程解决方案，其更强调「任务块」的概念，忽略了对线程的管理；<strong>GCD</strong> 是由 <strong>C</strong> 语言编写的轻量级线程处理方式，其源码在<a href="https://github.com/apple/swift-corelibs-libdispatch">这里</a>，在其内部维护了 <strong>pthread</strong> 生成的线程池的概念。</p><h3 id="任务-amp-队列"><a href="#任务-amp-队列" class="headerlink" title="任务 &amp; 队列"></a>任务 &amp; 队列</h3><p><strong>GCD</strong> 中的核心概念 「队列」 与 「任务」：</p><p>队列即执行任务的等待队列，以先进先出为原则执行队列中的任务，主要分为 <strong>串行队列</strong> 与 <strong>并行队列</strong></p><ul><li>串行队列（<strong>Serial Dispatch Queue</strong>）：每次只有一个任务执行。</li><li>并行队列（<strong>Concurrent Dispatch Queue</strong>）： 可以让多个任务并发执行。</li></ul><pre><code class="swift">let queue = DispatchQueue(label: "name") // 串行队列创建 / 默认let queue = DispatchQueue(label: "name", attributes: .concurrent) // 并行队列创建</code></pre><p>任务即你放入 <strong>GCD</strong> 中的代码块，分为同步和异步两种</p><ul><li>同步任务（<strong>sync</strong>）：同步任务会等待队列中前面的任务执行完再执行，在当前线程执行任务，不具备开启线程能力。</li><li>异步任务（<strong>async</strong>）：异步任务无需等待前面的任务执行完，即可继续执行任务，在新线程中执行任务，具备开启线程能力。</li></ul><pre><code class="swift">queue.sync { // 追加同步任务    print(Thread.current)} queue.async { // 追加异步任务    print(Thread.current)} </code></pre><p><strong>主队列</strong>：即主线程所在队列，是一个串行队列，可通过<code>DispatchQueue.main</code> 获取</p><p><strong>全局队列</strong>：并行队列，可通过<code>DispatchQueue.global()</code> 获取，同时还可根据任务优先级不同获取不同的全局队列：<code>DispatchQueue.global(qos: .background)</code></p><p>由于任务是追加到队列中，因此有 4 种组合方式：</p><table><thead><tr><th align="left"></th><th align="left">并发队列</th><th align="left">串行队列</th><th>主队列</th></tr></thead><tbody><tr><td align="left">同步（sync）</td><td align="left">没有开启新线程 / 串行执行任务</td><td align="left">没有开启新线程 / 串行执行任务</td><td>没有开启新线程 / 串行执行任务</td></tr><tr><td align="left">异步（async）</td><td align="left">开启新线程 / 并发执行任务</td><td align="left">开启新线程 / 串行执行任务</td><td>没有开启新线程 / 串行执行任务</td></tr></tbody></table><h3 id="GCD-中的死锁"><a href="#GCD-中的死锁" class="headerlink" title="GCD 中的死锁"></a>GCD 中的死锁</h3><blockquote><p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</p></blockquote><p>死锁有四个必要条件：互斥 &amp; 请求保持 &amp; 不可剥夺 &amp; 环路条件。</p><p>在 <strong>GCD</strong> 中，由于不当使用 <strong>API</strong> 则可能会造成死锁，这个死锁的概念不像上述表示那样，主要是任务间的相互等待导致无法执行任务造成，较为常见的如下：</p><p>在主线程中执行</p><pre><code class="swift">DispatchQueue.main.sync {    print(Thread.current) // 同步任务}// 当前任务</code></pre><pre><code class="swift">let queue = DispatchQueue.init(label: "name")    queue.sync {        queue.sync {              print(Thread.current) // 同步任务        }      } // 当前任务    print(Thread.current)  }</code></pre><p>原因：同步的任务无法开始，需等待当前队列中的任务执行完，而当前任务又因同步的任务导致无法完成。</p><h3 id="其他重要的API"><a href="#其他重要的API" class="headerlink" title="其他重要的API"></a>其他重要的<strong>API</strong></h3><h4 id="DiapatchGroup"><a href="#DiapatchGroup" class="headerlink" title="DiapatchGroup"></a>DiapatchGroup</h4><p>在追加多个异步任务后统一进行任务执行，可以采用 <strong>DispatchGroup</strong>，同样的基于手动将任务加入到 <strong>DispatchGroup</strong> 中(<strong>enter</strong> / <strong>leave</strong>)也可在多个网络请求后做同步操作。</p><pre><code class="swift">// 将任务加入到DispatchGrouplet group = DispatchGroup()let queue = DispatchQueue.init(label: "name", attributes: .concurrent)for i in 1...5 {    queue.async(group: group, execute: {      print("------ \(i)")    })}group.notify(queue: queue) {    print("end")}// 手动将任务加入到DispatchGrouplet group = DispatchGroup()let queue = DispatchQueue.init(label: "name", attributes: .concurrent)for i in 1...5 {    group.enter()    netwrk.api {        group.leave()    }}group.notify(queue: queue) {    print("end")}</code></pre><h4 id="栅栏函数-barrier"><a href="#栅栏函数-barrier" class="headerlink" title="栅栏函数(barrier)"></a>栅栏函数(barrier)</h4><p>栅栏任务会在前面任务都执行完后执行，在栅栏任务执行完后才会执行后面追加的任务，在具体场景中，可以用于“读者-写者问题”，即同一时刻可以有多个读者，但同一时刻只能有一个写者，如数据库的读写操作。</p><img src="/images/blog/image-20220328172310546.png" alt="image-20220328172310546" style="zoom: 67%;"><pre><code class="swift">queue.async(group: nil, qos: .default, flags: .barrier) {    print("隔离")}</code></pre><h4 id="延迟执行-asyncAfter"><a href="#延迟执行-asyncAfter" class="headerlink" title="延迟执行(asyncAfter)"></a>延迟执行(asyncAfter)</h4><p>延迟指定时间后将延迟任务加入到队列中，需要注意的是可以传递 <strong>DispatchTime</strong> 和 <strong>DispatchWallTime</strong> 这两个时间，前者是基于系统时间，不可被改变，后者为系统时钟，即锁屏界面的时间。</p><pre><code class="swift">queue.asyncAfter(deadline: .now() + 1) {    print("执行")}</code></pre><h4 id="信号量-semaphore"><a href="#信号量-semaphore" class="headerlink" title="信号量(semaphore)"></a>信号量(semaphore)</h4><p><strong>DispatchSemaphore</strong> 与 操作系统中的信号量一样，都是用来避免数据竞争这一类问题的，在 <strong>iOS</strong> 中常用来控制并发任务执行的最大数量。</p><ul><li>**singal()**：将 信号量 + 1</li><li>**wait()**：若此时信号量 &gt;= 1时，将信号量减 1，然后返回；若信号量 &lt;= 0时，则阻塞线程进行等待。</li></ul><pre><code class="swift">let semaphore = DispatchSemaphore(value: 3) // 将并发任务执行数量控制为3let queue = DispatchQueue.init(label: "name", attributes: .concurrent)for i in 1...5 {    semaphore.wait()    queue.async {        print(i)        semaphore.signal()    }}</code></pre><h4 id="调度源-DispatchSource"><a href="#调度源-DispatchSource" class="headerlink" title="调度源(DispatchSource)"></a>调度源(DispatchSource)</h4><p><strong>DispatchSource</strong> 用于监听系统的底层对象，比如文件描述符、<strong>Mach</strong> 端口、信号量、内存警告等。主要处理时间如下表：</p><table><thead><tr><th align="left">宏定义</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">DispatchSourceUserDataAdd</td><td align="left">数据增加</td></tr><tr><td align="left">DispatchSourceUserDataOr</td><td align="left">数据OR</td></tr><tr><td align="left">DispatchSourceMachSend</td><td align="left">Mach端口发送</td></tr><tr><td align="left">DispatchSourceMachReceive</td><td align="left">Mach端口接收</td></tr><tr><td align="left">DispatchSourceMemoryPressure</td><td align="left">内存情况</td></tr><tr><td align="left">DispatchSourceProcess</td><td align="left">进程事件</td></tr><tr><td align="left">DispatchSourceRead</td><td align="left">读数据</td></tr><tr><td align="left">DispatchSourceSignal</td><td align="left">信号</td></tr><tr><td align="left">DispatchSourceTimer</td><td align="left">定时器</td></tr><tr><td align="left">DispatchSourceFileSystemObject</td><td align="left">文件系统变化</td></tr><tr><td align="left">DispatchSourceWrite</td><td align="left">文件写入</td></tr></tbody></table><p>例如：</p><p><strong>监听内存情况</strong></p><pre><code class="swift">var source = DispatchSource.makeMemoryPressureSource(eventMask: .all, queue: .main)source.setEventHandler {    print(source.data)    // data为枚举值的rawValue, 主要有 normal、warning、critical、all}source.activate()</code></pre><p><strong>定时器</strong></p><pre><code class="swift">var source: DispatchSourceTimer?source = DispatchSource.makeTimerSource(flags: .strict, queue: .main)source?.schedule(deadline: .now() + 1, repeating: 1)source?.setEventHandler {    print("定时器触发\(Date.now)")}source?.activate()</code></pre><p>值得注意的是，在使用 <strong>NSTimer</strong> 时，若在滑动页面时，此 <strong>NSTimer</strong> 会失效，需给 <strong>timer</strong> 加入的 <strong>RunLoop</strong> 添加 <strong>commonMode</strong> 模式，若采用  <strong>DispatchSourceTimer</strong>，则不会出现这种情况。</p><p>需注意以上代码 <code>source</code> 不要以局部变量进行测试，否则超出作用域就被释放。</p><h4 id="DispatchIO"><a href="#DispatchIO" class="headerlink" title="DispatchIO"></a>DispatchIO</h4><p><strong>DispatchIO</strong> 提供一个操作文件描述符的通道，可以利用多线程高效的读取文件。以下是主要流程：</p><ol><li>创建 <strong>DispatchIO</strong> 对象，创建通道</li><li>进行 <strong>read</strong> / <strong>write</strong> 操作</li><li>调用 <strong>close</strong> 关闭通道</li><li>进行 <strong>cleanupHandler</strong> 回调处理</li></ol><pre><code class="swift">var ioWrite: DispatchIO?var ioRead: DispatchIO?let queue = DispatchQueue(label: "com.nihao.serialQueue")let filePath: NSString = (NSTemporaryDirectory() + "text.txt") as NSStringlet fileDescriptor = open(filePath.utf8String!, (O_RDWR | O_CREAT | O_APPEND), (S_IRWXU | S_IRWXG))let cleanupHandler: (Int32) -&gt; Void = { errorNumber in    print("最后的回调")}ioWrite = DispatchIO(type: .stream, fileDescriptor: fileDescriptor, queue: queue, cleanupHandler: cleanupHandler)ioRead = DispatchIO(type: .stream, fileDescriptor: fileDescriptor, queue: queue, cleanupHandler: cleanupHandler)let formattedString = "nihao!!!!!"let data = Array(formattedString.utf8).withUnsafeBytes {    DispatchData(bytes: $0)}ioWrite?.write(offset: 0, data: data, queue: queue) { done, data, error in }ioRead?.read(offset: 0, length: Int.max, queue: queue) { done, data, error in }</code></pre><h2 id="NSOperation"><a href="#NSOperation" class="headerlink" title="NSOperation"></a>NSOperation</h2><p><strong>NSOperation</strong> 是基于 <strong>GCD</strong> 的面向对象的封装，因此也有「任务 <strong>NSOperation</strong>」和「队列 <strong>NSOperationQueue</strong>」两个概念，同时也增加了 <strong>NSOperation</strong> 之间相互依赖、通过 <strong>KVO</strong> 监听 <strong>NSOperation</strong> 状态、取消任务等特性。</p><p><strong>NSOperation</strong> 是一个形式上的抽象类，系统提供了 <strong>NSInvocationOperation</strong> 和 <strong>NSBlockInvocation</strong> 两个子类，但由于 <strong>NSInvocation</strong> 在 <strong>Swift</strong> 中不可使用，所以在 <strong>Swift</strong> 中 <strong>NSInvocationOperation</strong> 也不可用。同时也可以自定义 <strong>NSOperation</strong>，若仅使用 <strong>NSOperation</strong> 则任务只会在主线程运行，因此需和 <strong>NSOperationQueue</strong> 搭配使用。</p><p><strong>NSOperationQueue</strong> 初始化后就是一个并发队列，它会根据优先级与准备情况调用任务，可通过类属性 <code>main</code> 获取主队列，主要是通过给队列添加 <strong>operation</strong> 进行操作。值得注意的是，当任务已经被执行或执行已结束后就不能被再次添加进队列，否则会产生 <strong>crash</strong>。下面是一些使用范例：</p><pre><code class="swift">let queue = OperationQueue()queue.maxConcurrentOperationCount = 2 //设置最大并发数let operationA = BlockOperation { () -&gt; Void in    print("A - \(Thread.current)")}let operationB = BlockOperation { () -&gt; Void in    print("B - \(Thread.current)")}operationA.addDependency(operationB) // A 依赖于 B, 当 B 执行后 A 才会执行queue.addOperation(operationA)queue.addOperation(operationB)queue.addBarrierBlock {    print("我是屏障")}queue.addOperation { () -&gt; Void in    print("2 - \(Thread.current)")}</code></pre><h3 id="自定义-NSOperation"><a href="#自定义-NSOperation" class="headerlink" title="自定义 NSOperation"></a>自定义 NSOperation</h3><p>通常来说非并发 <strong>NSOperation</strong>，自定义 <strong>NSOperation</strong> 不是一件困难的事，只需要重写 <code>start()</code> 方法，将需要执行的操作写入即可。但如果想要自定义并发 <strong>NSOperation</strong>，需要至少实现以下方法和属性：</p><ul><li><code>start()</code></li><li><code>isAsynchronous</code></li><li><code>isExecuting</code></li><li><code>isFinish</code></li></ul><p>总的来说需要在执行函数的去维护 <strong>NSOperation</strong> 的一些状态，如果还进行了 <strong>KVO</strong> 监听，还需要去发出 <strong>KVO</strong> 通知以反映值的改变。具体可以参考 <strong>Apple</strong> 的文档 <a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationObjects/OperationObjects.html#//apple_ref/doc/uid/TP40008091-CH101-SW16">自定义NSOperation 对象</a></p><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><blockquote><p>在拥有共享数据的多条线程并行执行的程序中，线程安全的代码会通过同步机制保证各个线程都可以正常且正确的执行，不会出现数据污染等意外情况。</p></blockquote><p>再体会到了多线程的好处之后，需要对数据的安全情况进行保证。线程安全就是为了保证被多线程执行的过程中能够得到正确的结果，即数据不被污染。保证线程安全有「同步」和「非同步」两种方案。「同步」是指在多线程并发访问数据的过程中，保证共享数据在同一时刻只被一个线程使用，例如加锁。「非同步」是指在某些情况下不需要「同步」操作，例如函数本身就不涉及到共享代码，自然也就不需要「同步」去保证数据安全。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="无同步"><a href="#无同步" class="headerlink" title="无同步"></a>无同步</h4><p><strong>可重入代码</strong>（<strong>ReentrantCode</strong>）：可以在这个函数执行的任何时刻中断它，转入 **OS **调度下去执行另外一段代码，而返回控制时不会出现什么错误，这意味着它除了使用自己栈上的变量外不依赖于其他任何变量。这种情况每次执行结果都一样，且不会依赖共享变量，在无同步情况下保证了线程安全。</p><p><strong>线程本地存储</strong>：若线程中需要的数据必须与其他线程共享，尝试判断这个共享的数据能否保证只在同一线程执行，如果可以，则可以对该线程创建一份共享变量的副本，这样也可以实现无同步保证线程安全。例如：</p><pre><code class="swift">class Person: NSCopying {    func copy(with zone: NSZone? = nil) -&gt; Any {        return Person(-1, name: "")    }    var age: Int    var name: String    init(_ age: Int, name: String) {        self.age = age        self.name = name    }}var person = Person.init(2, name: "") // 全局变量let queue = DispatchQueue.init(label: "name")for i in 0...100 {    queue.async {        var currPerson = self.person.copy()    }}</code></pre><p>若线程中每次都需要访问 <strong>person</strong>，且在后面不需要同步回原始 <strong>person</strong>，仅在当前线程中操作，也可保证线程安全。</p><h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><p><strong>互斥同步</strong>：也称非阻塞同步，是指调用返回结果前，当前线程会被挂起进入阻塞状态，只有在得到结果后才继续，是一种悲观的同步策略。在 <strong>iOS</strong> 中以主要以互斥锁方式体现，在获取互斥锁失败后，会进入阻塞状态，等待锁被释放以被唤醒。</p><p><strong>非阻塞同步</strong>：是指在不能得到结果前，当前线程不会进入阻塞状态，是一种乐观的同步策略。在 <strong>iOS</strong> 中以主要以自旋锁的方式体现，在获取锁失败后不会进入阻塞状态，而是不断尝试获取锁，锁被释放，因为不涉及线程状态切换，所以效率高于互斥锁。</p><p>除了锁之外还有的同步工具，如 <strong>Atomic Operations</strong>、<strong>Memory Barries</strong>、<strong>Volatile Variables</strong>，下面进行简要介绍：</p><ul><li><strong>Atomic Operations</strong>：原子操作是一种简单的同步形式，适用于简单的数据结构，它不会阻塞竞争线程；<strong>OS X</strong> 和 <strong>iOS</strong> 包含了许多对 32 位和 64 位值执行基本数学和逻辑运算操作。如<code>atomic_fetch_add</code>、<code>atomic_exchange</code>等，具体可<a href="https://en.cppreference.com/w/c/atomic">参考</a>。</li><li><strong>Memory Barries</strong>：在单线程中，由于硬件会执行必要的记录，以确保程序的内存操作的执行顺序就像代码顺序一样；但是在多线程中，由于编译器为了优化经常对汇编级指令进行重排，就可能会导致产生潜在的错误。内存屏障是一种非阻塞同步工具，用于确保内存操作以正确顺序发生。例如：</li></ul><pre><code class="swift">// thread1:while f == 0 {}print(x)// thread2:x = 5f = 1</code></pre><p>并非每次都打印数字 <strong>5</strong>，如果 <strong>thread2</strong> 乱序执行，先执行 <code>f = 1</code>，后执行 <code>x = 5</code>，则可能会出现意外的值，因此引入了内存屏障，在需要确保执行顺序中插入 <code>OSMemoryBarrier</code>，具体可<a href="https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man3/OSMemoryBarrier.3.html#//apple_ref/doc/man/3/OSMemoryBarrier">参考</a>。</p><ul><li><strong>Volatile Variables</strong>：声明为 <strong>volatile</strong> 的变量不会被优化。例如变量被编译器优化，被放置于寄存器中并读取，这就有潜在读取风险，而 <strong>volatile</strong> 阻止了这种优化，每次都会从内存中读取变量的当前值。</li></ul><p>内存屏障 和 **volatile **变量都会减少编译器的优化次数，因此只需要在确保正确的地方使用它们。在 <strong>GCD</strong>、 <strong>NSOperation</strong> 中有着许多内存屏障代码，让我们能遇上这种情况微乎其微。</p><h2 id="iOS-中的锁"><a href="#iOS-中的锁" class="headerlink" title="iOS 中的锁"></a>iOS 中的锁</h2><p>在 <strong>iOS</strong> 中，实现线程安全一般以锁来进行线程同步，下面对主要的几种锁进行简要介绍以及性能对比。</p><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="@synchronized"></a>@synchronized</h3><pre><code class="objective-c">@synchronized (obj) {    // 需要同步的代码      NSLog(@"nihao")!}</code></pre><p><strong>@synchronized</strong> 是一个递归锁，其实现采用了 <strong>recursive_mutex_t</strong> ，递归锁即在同一个线程中获取锁多次，只能传递一个 <strong>NSObject</strong> 对象，在 <strong>Swift</strong> 中将此语法移除，将其还原为 <strong>C++</strong> 后可以发现其源码类似如下：</p><pre><code class="objective-c">objc_sync_enter(_sync_obj);// 需同步的代码NSLog(@"nihao")!objc_sync_exit(_sync_obj);</code></pre><p>因此在 <strong>Swift</strong> 中可以利用这两个函数模拟出 <strong>@synchronized</strong></p><pre><code class="swift">func synchronized(lock: AnyObject, closure: () -&gt; Void) {    objc_sync_enter(lock)    closure()    objc_sync_exit(lock)}</code></pre><h3 id="NSLock-amp-NSRecursiveLock"><a href="#NSLock-amp-NSRecursiveLock" class="headerlink" title="NSLock &amp; NSRecursiveLock"></a>NSLock &amp; NSRecursiveLock</h3><pre><code class="swift">let lock = NSLock()lock.lock()// 需同步的代码lock.unlock()let recursiveLock = NSRecursiveLock()recursiveLock.lock()// 需同步的代码recursiveLock.unlock()</code></pre><p><strong>NSLock</strong> 和 <strong>NSRecursiveLock</strong> 在使用上一致，<strong>NSLock</strong> 是一个互斥锁，而 <strong>NSRecursiveLock</strong> 是一个递归锁，都对 <strong>pthread_mutex</strong> 的封装，在使用场景中需考虑是否在同一线程中多次加锁。</p><h3 id="NSCondition-amp-NSConditionLock"><a href="#NSCondition-amp-NSConditionLock" class="headerlink" title="NSCondition &amp; NSConditionLock"></a>NSCondition &amp; NSConditionLock</h3><p><strong>NSCondition</strong> 基于 <code>pthread_mutex</code> 实现，是一个条件锁，其内部维护了一个锁以及一个线程检查器：锁主要是为了同步临界区；线程检查器主要是根据条件决定是否继续运行。</p><ul><li><code>wait()</code>：让当前线程处于等待中</li><li><code>singal()</code>：通知某一个线程从阻塞状态恢复到就绪状态</li><li><code>broadcast()</code>：通知其他所有线程从阻塞状态恢复到就绪状态</li></ul><p>比较常见的例子如生产者消费者模型：</p><pre><code class="swift">var condition = NSCondition() // 锁var money = 5 // 共享变量// thread1func consume() {    condition.lock()    while money == 0 {        condition.wait()    }    money -= 1    condition.unlock()}// thread2func product() {    condition.lock()    money += 1    condition.wait()    condition.unlock()}</code></pre><p><strong>NSConditionLock</strong> 定义了一个互斥锁，可以用于特定的值锁定与解决。其与 <strong>NSCondition</strong> 的行为有些类似，上面的代码可以转换为：</p><pre><code class="swift">var condition = NSConditionLock(condition: 0)var money = 0// 0表示无数据 1表示有数据func consume() {    condition.lock(whenCondition: 1)    money -= 1    condition.unlock(withCondition: money == 0 ? 0 : 1) }func product() {    condition.lock()    money += 1    condition.unlock(withCondition: 1)}</code></pre><h3 id="NSDistrubutedLock"><a href="#NSDistrubutedLock" class="headerlink" title="NSDistrubutedLock"></a>NSDistrubutedLock</h3><p><strong>NSDistrubutedLock</strong> 是一个分布式锁，通常在多个主机上的多个应用程序用来限制对某些共享资源的访问，比如文件，它由文件系统项(例如文件或目录)实现，不过由于 <strong>iOS</strong> 应用的沙盒机制，并未有相应 <strong>API</strong>，在 <strong>OS X</strong> 中可以使用。</p><h3 id="DispatchSemaphore"><a href="#DispatchSemaphore" class="headerlink" title="DispatchSemaphore"></a>DispatchSemaphore</h3><p>上文有对 <strong>DispatchSemaphore</strong> 做介绍，这里就不赘述。</p><h3 id="OSSpinLock"><a href="#OSSpinLock" class="headerlink" title="OSSpinLock"></a>OSSpinLock</h3><p><strong>OSSpinLock</strong> 是自选锁，但由于 <strong>iOS</strong> 系统中线程可以拥有不同的优先级，可能会产生优先级反转问题。具体来说，在低优先级的线程获得锁并访问共享资源，此时高优先级线程也尝试获取，由于 <strong>OSSpinLock</strong> 是自选锁，它会进入忙等状态并占用大量 <strong>CPU</strong>，进而导致低优先级线程无法与高优先级线程抢占 <strong>CPU</strong>，进而导致任务迟迟无法完成、无法释放 <strong>lock</strong>，因此 <strong>OSSpinLock</strong> 已经被弃用了，使用 <strong>os_unfair_lock</strong> 代替，这也是个互斥锁。</p><pre><code class="objective-c">OSSpinLockLock(&amp;spinlock) // 获取锁，线程一直忙等待。阻塞当前线程执行。OSSpinLockTry(&amp;spinlock) // 尝试获取锁，返回bool。当前线程锁失败，也可以继续其它任务，不阻塞当前线程。OSSpinLockUnlock(&amp;spinlock) // 解锁，参数是OSSpinLock地址。</code></pre><h3 id="atomic"><a href="#atomic" class="headerlink" title="atomic"></a>atomic</h3><p><strong>Objective-C</strong> 中属性中的关键字，会对属性的存值与取值进行加锁处理。它是基于<code>os_unfair_lock</code>进行实现，上文提到过，这是一个互斥锁，它不能保证线程安全，只能保证存取值的安全性。</p><h3 id="各种锁的性能比较"><a href="#各种锁的性能比较" class="headerlink" title="各种锁的性能比较"></a>各种锁的性能比较</h3><p>图片截取自 <a href="https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/#more-41952">不再安全的 OSSpinLock</a>，做一个小的推测：</p><p>先讨论锁，然后再分析信号量。</p><p><strong>OSSpinLock</strong> 由于自选锁的特性不会线程状态切换因此排在第一；</p><p>之后的锁都是基于 <strong>POSIX thread</strong> 的相关线程 <strong>API</strong>进行封装，性能根据封装强度不同而有所不同，比如互斥锁性能好于递归锁，同时也好于条件锁；</p><p>信号量其实与锁类似，但<code>pthread_mutex</code>支持多种类型，因此会有额外的判断，就造成了效率略低原因。</p><p>但这些锁虽性能有所差异，但都差距不大，在编码过程中还因考虑具体的场景和代码健壮性等方面。</p><img src="/images/blog/lock_benchmark.png" alt="lock_benchmark" style="zoom:75%;"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文就 <strong>iOS</strong> 中多线程这一点，概述了 <strong>NSThread</strong>、<strong>GCD</strong>、<strong>NSOperation</strong> 这三种多线程使用说明和它们的特点，以及关于线程安全介绍了一些同步手段和关于锁的一些使用。就本人而言，在平时工作中使用 <strong>GCD</strong> 较多，它是多线程编程的核心，应该更多的关注它，同时关于它们的源码，笔者由于水平有限，不能做出较为有理解的看法，就不做过多探讨，希望在后续过程中能够加强这方面的学习。</p><h2 id="🔗"><a href="#🔗" class="headerlink" title="🔗"></a>🔗</h2><ul><li><p>《<strong>Objective-C</strong> 高级编程 - <strong>iOS</strong> 与 <strong>OS X</strong> 多线程和内存管理》</p></li><li><p><a href="https://ming1016.github.io/2016/01/13/how-to-use-gcd/">细说GCD(Grand Central Dispatch)</a></p></li><li><p><a href="http://yulingtianxia.com/blog/2015/11/01/More-than-you-want-to-know-about-synchronized/">关于 @synchronized，这儿比你想知道的还多</a></p></li><li><p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/ThreadSafety/ThreadSafety.html#//apple_ref/doc/uid/10000057i-CH8-SW1">Threading Programming Guide</a></p></li><li><p><a href="https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/#more-41952">不再安全的 OSSpinLock</a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在 &lt;strong&gt;iOS&lt;/strong&gt; 中有 3 种线程管理安全，分别是 &lt;strong&gt;NSThread&lt;/strong&gt;、&lt;strong&gt;GCD&lt;/strong&gt; 与 &lt;strong&gt;NSOperation&lt;/strong&gt;，不包含几乎不直接使用的 &lt;strong&gt;pthread&lt;/strong&gt; 。本文就其使用特点以及重要的 &lt;strong&gt;API&lt;/strong&gt; ，以及线程安全等方面进行总结。&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://xuhaodong1.github.io/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://xuhaodong1.github.io/tags/iOS/"/>
    
    <category term="多线程" scheme="https://xuhaodong1.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="GCD" scheme="https://xuhaodong1.github.io/tags/GCD/"/>
    
    <category term="锁" scheme="https://xuhaodong1.github.io/tags/%E9%94%81/"/>
    
    <category term="NSThread" scheme="https://xuhaodong1.github.io/tags/NSThread/"/>
    
  </entry>
  
  <entry>
    <title>Swift 内存模型与方法调度</title>
    <link href="https://xuhaodong1.github.io/2022/03/13/SwiftMemoryLayoutMethodDispatch/"/>
    <id>https://xuhaodong1.github.io/2022/03/13/SwiftMemoryLayoutMethodDispatch/</id>
    <published>2022-03-13T14:54:49.000Z</published>
    <updated>2022-12-20T13:01:35.755Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文从内存分区、内存对齐、内存模型与方法派发角度介绍了关于 Swift 中的一些知识点。</p><span id="more"></span><h2 id="内存分区"><a href="#内存分区" class="headerlink" title="内存分区"></a>内存分区</h2><p>iOS 应用内存分为 5 个区域，其中“全局区”、“常量区” 和 “代码区”的内存空间在编译时确定，“栈”、“堆”的内存空间在运行时确定。</p><p><img src="/images/blog/iOS%E5%BA%94%E7%94%A8%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA.png" alt="iOS应用内存分区"></p><ul><li>栈区：存储值类型的局部变量，函数参数，其大小有限，连续分配，向低地址拓展；由在运行时系统自动分配和释放内存空间，每一个线程都有其对应的栈。</li><li>堆区：存储引用类型，不连续的内存区域，向高地址拓展，大小受限于系统中的虚拟内存；由程序员动态创建和释放对象，在运行时分配。</li><li>全局/静态区：存储未初始化的全局变量和静态变量，即 .bss ；和已初始化的全局变量和静态变量，即 .data。</li><li>常量区：存储字符串常量</li><li>代码区：存储程序运行时的代码</li></ul><h2 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h2><p><strong>为什么需要内存对齐：</strong></p><ol><li>某些硬件不能随意访问任意地址</li><li>提高访问效率</li></ol><p><strong>内存对齐原则：</strong></p><ol><li>结构体第一个成员的<strong>偏移量（offset）</strong>为0，以后每个成员相对于结构体首地址的 <strong>offset</strong> 都是<strong>该成员大小与对齐系数中较小值</strong>的整数倍，如有需要编译器会在成员之间加上填充字节。</li><li><strong>结构体的总大小</strong>为对齐系数的<strong>整数倍</strong>，如有需要编译器会在最末一个成员之后加上填充字节。</li></ol><p>注：结构体可代替为 <strong>class</strong>、<strong>protocol</strong>等任意类型，只是其他类型内存分布与结构体不同。</p><p>在 <strong>Swift</strong> 中：</p><pre><code class="Swift">MemoryLayout&lt;T&gt;.size // 属性占用大小(与其属性匹配)MemoryLayout&lt;T&gt;.stride // 实际占用大小MemoryLayout&lt;T&gt;.alignment // 对齐系数</code></pre><h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><h3 id="struct"><a href="#struct" class="headerlink" title="struct"></a><strong>struct</strong></h3><p>例：</p><pre><code class="swift">struct Foo {    let a: Int8 = 2   // 1 byte    let b: Int16 = 4  // 2 bytes    let c: Int32 = 6  // 4 bytes    let d: Int = 8    // 8 bytes        func foo() {        print("Hello")    }}let foo = Foo()print(MemoryLayout&lt;Foo&gt;.size)print("===end===")</code></pre><img src="/images/blog/截屏2021-12-26 10.27.40.png" alt="image-20211226103015351" style="zoom: 67%;"><p>可以看出，<strong>struct</strong> 的内存是连续分布的，但是由于<strong>内存对齐原则</strong>，属性 <strong>a</strong> 所占用内存空间为 <strong>2 byte</strong>，对于实例方法其内部并不会做存储，而是在编译后直接指向方法的地址。</p><h3 id="class"><a href="#class" class="headerlink" title="class"></a><strong>class</strong></h3><p><strong>Swift</strong> 与 <strong>Objective-C</strong> 中的 <strong>Class</strong> 类型，为了兼容 <strong>Objective-C</strong> 且具有更多的 <strong>Swift</strong> 特性，在 <strong>Swift</strong> 源码中，其类型为 <code>swift_class_t</code> 的结构体，继承于 <code>objc_class</code>。其内存布局如下图所示：</p><p><img src="/images/blog/image-20220313210720322-7176842.png" alt="image-20220313210720322"></p><p><strong>isa</strong>：与 <strong>Objective-C</strong> 中 <strong>isa</strong> 一样，包含了这个类型的信息，如 父类的 <strong>isa</strong> 信息、是否存在关联对象、以及 <strong>virtual table</strong> 用以方法调用等内容。</p><p><strong>retain count</strong>：记录其引用计数值</p><h3 id="protocol"><a href="#protocol" class="headerlink" title="protocol"></a><strong>protocol</strong></h3><p>看下面源码</p><pre><code class="swift">protocol Drawable { func draw() }struct Point : Drawable {    var x: Int    var y: Int    func draw() { print("Point") }}struct Line : Drawable {    var x1, y1, x2, y2: Int    func draw() { print("Line") }}class Cricle: Drawable {    var r: Int = 5    func draw() { print("SharedLine") }}struct Simple {    var drawable1: Drawable    var drawable2: Drawable    var drawable3: Drawable    func printMemoryLayout() {        MemoryLayout.size(ofValue: drawable1)        MemoryLayout.size(ofValue: drawable2)        MemoryLayout.size(ofValue: drawable3)    }}</code></pre><p>首先在 <strong>Build Setting</strong> 中，将 <strong>Reflection Metadata Level</strong> 改为 <strong>None</strong>，调用 <code>printMemoryLayout</code> 再进行调试。</p><pre><code>404040</code></pre><p><img src="/images/blog/image-20220313200904959-7173347.png" alt="image-20220313200904959"></p><p><strong>Reflection Metadata Level</strong> 改为 <strong>None</strong>，是防止编译器将反射元数据发送到二进制文件中，会对分析造成干扰。</p><p>对于协议类型来说，为了实现语义上的多态，且创建时其内存大小是不固定的，因此引入了新的内存结构进行处理。</p><p>可以看到输出内存占用大小全部为 40，且都拥有相同的数据结构。如下图所示：</p><p><img src="/images/blog/image-20220311002137424-6929301.png" alt="image-20220311002137424"></p><p><strong>valueBuffer</strong>：3位，对于空间小于或等于 <strong>valueBuffer</strong> 的值，直接存储在 <strong>valueBuffer</strong> 中；对于空间大于 valueBuffer的值，则会在堆中开辟内存空间，<strong>valueBuffer</strong> 则存储其引用地址。对应 <code>drawable1</code> 与 <code>drawable2</code>。</p><p><strong>value witness table</strong>：由于每个协议类型的初始化不尽相同，所以每一种类型(上上图的 <strong>metadata</strong> )都会有一个 <strong>value witness table</strong>，用于进行生命周期管理，有 <code>alloc</code>、<code>copy</code>、<code>destruct</code>、<code>deallocate</code> 等方法。</p><p><strong>protocol witness table</strong>：类似于 <strong>class</strong> 的 <strong>virtual table</strong>，用以存储每个协议类型的方法。每种类型会创造 <code>PWT</code> 表，内部包含指针，指向方法具体实现。</p><h2 id="方法派发"><a href="#方法派发" class="headerlink" title="方法派发"></a>方法派发</h2><p>方法派发是指告诉 <strong>CPU</strong> 如何去找到该函数地址并进行调用的过程，在 <strong>Swift</strong> 中分为 3 种派发机制，分别是静态派发、函数表派发与动态派发。那么什么时候会是什么样的方法派发呢？主要有两方面纬度的考量：</p><h3 id="声明类型"><a href="#声明类型" class="headerlink" title="声明类型"></a>声明类型</h3><p>对于不同的声明位置来说，其方法派发的是不同的，若下图所示：</p><table><thead><tr><th></th><th>类中声明</th><th>拓展声明</th></tr></thead><tbody><tr><td>value type</td><td>static</td><td>static</td></tr><tr><td>protocol</td><td>table</td><td>static</td></tr><tr><td>class</td><td>table</td><td>static</td></tr><tr><td>NSObject SubClass</td><td>table</td><td>message</td></tr></tbody></table><p><strong>规律：</strong></p><p>值类型都是静态派发</p><p>协议和类中的拓展都是静态派发</p><p><strong>NSObject</strong> 拓展采用消息派发，类中声明采用函数表派发</p><p>协议中默认实现使用函数表派发</p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>对于某些关键字来说，也能够改变其派发方式：</p><table><thead><tr><th>关键字</th><th>派发方式</th></tr></thead><tbody><tr><td>final</td><td>static</td></tr><tr><td>dynamic</td><td>Message</td></tr><tr><td>@objc &amp; @nonobjc</td><td>修改 Objective-C 可见性</td></tr><tr><td>@inline</td><td>Static</td></tr></tbody></table><p><strong>规律：</strong></p><p>final - 静态派发</p><p>dynamic - 消息派发</p><p>@objc &amp; @nonobjc - 声明函数能否被 objective-c runtime捕捉到</p><p>final @objc - 调用时静态派发，但会将函数注册到 objective-c runtime中</p><p>@inline - 直接派发，但如果是 dynamic @inline，则会采用消息派发</p><p>结合上两图总结如下：</p><table><thead><tr><th></th><th>直接派发</th><th>函数表派发</th><th>消息派发</th></tr></thead><tbody><tr><td>NSObject</td><td>@nonobjc / final</td><td>类中声明</td><td>拓展申明 且 dynamic</td></tr><tr><td>class</td><td>拓展声明 且 final</td><td>类中声明</td><td>dynamic</td></tr><tr><td>protocol</td><td>拓展声明</td><td>类中声明</td><td>@objc</td></tr><tr><td>value type</td><td>所有方法</td><td>无</td><td>无</td></tr></tbody></table><h3 id="静态派发："><a href="#静态派发：" class="headerlink" title="静态派发："></a><strong>静态派发</strong>：</h3><p>指编译时直接跳转到函数的地址，调用速度最快，同时可能经过编译器优化成 <strong>inline</strong>。</p><p>在 <strong>Swift</strong> 中，值类型的方法调用与 <strong>final</strong> 修饰的是静态派发。（值类型与 <strong>final</strong> 不支持继承与 <strong>override</strong>）</p><h3 id="函数表派发："><a href="#函数表派发：" class="headerlink" title="函数表派发："></a><strong>函数表派发：</strong></h3><p>为在类中申明过的所有方法生成一个函数指针数组</p><p><strong>virtual table / protocol witness table</strong></p><img src="/images/blog/1_4YaI2HPK48IqgyK3DpU_VQ.png" alt="A diagram showing the memory offsets for method1, method2, and method3 in ParentClass and ChildClass." style="zoom:80%;"><p>相较于静态派发，速度更慢，需要两次读取地址与一次跳转，同时编译器无优化操作，将自身作为实例作为隐含参数传递到方法中。例如下面一段协议类型的方法调用的 <strong>SIL</strong> 代码如下：</p><pre><code class="swift">// drawACopy(drawables:)sil hidden @$s14ViewController9drawACopy9drawablesyAA8Drawable_p_tF : $@convention(thin) (@in_guaranteed Drawable) -&gt; () {// %0 "drawables"                                 // users: %2, %1bb0(%0 : $*Drawable):  debug_value_addr %0 : $*Drawable, let, name "drawables", argno 1 // id: %1  %2 = open_existential_addr immutable_access %0 : $*Drawable to $*@opened("F57086CE-A07E-11EC-86EE-ACDE48001122") Drawable // users: %4, %4, %3  %3 = witness_method $@opened("F57086CE-A07E-11EC-86EE-ACDE48001122") Drawable, #Drawable.draw : &lt;Self where Self : Drawable&gt; (Self) -&gt; () -&gt; (), %2 : $*@opened("F57086CE-A07E-11EC-86EE-ACDE48001122") Drawable : $@convention(witness_method: Drawable) &lt;τ_0_0 where τ_0_0 : Drawable&gt; (@in_guaranteed τ_0_0) -&gt; () // type-defs: %2; user: %4  %4 = apply %3&lt;@opened("F57086CE-A07E-11EC-86EE-ACDE48001122") Drawable&gt;(%2) : $@convention(witness_method: Drawable) &lt;τ_0_0 where τ_0_0 : Drawable&gt; (@in_guaranteed τ_0_0) -&gt; () // type-defs: %2  %5 = tuple ()                                   // user: %6  return %5 : $()                                 // id: %6} // end sil function '$s14ViewController9drawACopy9drawablesyAA8Drawable_p_tF'</code></pre><p>可以看到对于协议类型，会通过 <code>open_existential_addr</code> 创建一个局部变量 <code>%2</code>，在通过 <code>%2</code> 找到其对应<code>witness_method</code> - <code>%3</code>，最后再通过 <code>%2</code> 与作为入参执行方法 （<code>apply</code>） <code>%3</code>。</p><h3 id="动态派发："><a href="#动态派发：" class="headerlink" title="动态派发："></a>动态派发：</h3><p>与 <strong>Objective-C</strong> 一致，会被翻译成 <strong>objc_send</strong> 这样的代码，会经过 <strong>cache</strong> 查找、通过 <strong>isa</strong> 指针在当前类与父类的 <strong>method_list</strong> 查找、最后到消息转发流程。动态派发的速度最慢，但可功能性最强。</p><p>网上关于动态派发的文章很多，这里不再赘述，详情参考：<a href="https://juejin.cn/post/6844903575437606920#heading-6">iOS 消息发送与转发详解</a></p><h2 id="🔗"><a href="#🔗" class="headerlink" title="🔗"></a>🔗</h2><p><a href="https://www.jianshu.com/p/e5a54813b93d">iOS-底层原理 24: 内存5大区</a></p><p><a href="https://swiftunboxed.com/internals/size-stride-alignment/">Size, Stride, Alignment</a></p><p><a href="https://github.com/LeoMobileDeveloper/Blogs/blob/master/Swift/Method%20Dispatch%20and%20Memory%20Layout.md#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D">Swift 方法调度与内存布局</a></p><p><a href="https://zhuanlan.zhihu.com/p/35696161">Swift 中的方法调用（Method Dispatch）（一） - 概述</a></p><p><a href="https://juejin.cn/post/6968799729853399053#note3">[译] Swift 中的方法派发</a></p><p><a href="https://www.rightpoint.com/rplabs/switch-method-dispatch-table">switch-method-dispatch-table</a></p><p><a href="https://academy.realm.io/posts/goto-mike-ash-exploring-swift-memory-layout/">Exploring Swift Memory Layout</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文从内存分区、内存对齐、内存模型与方法派发角度介绍了关于 Swift 中的一些知识点。&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://xuhaodong1.github.io/categories/iOS/"/>
    
    
    <category term="Swift" scheme="https://xuhaodong1.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>iOS 启动优化</title>
    <link href="https://xuhaodong1.github.io/2022/03/07/iOS%20%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/"/>
    <id>https://xuhaodong1.github.io/2022/03/07/iOS%20%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/</id>
    <published>2022-03-07T14:54:49.000Z</published>
    <updated>2022-12-20T13:01:35.265Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>启动时间往往是一个用户对 APP 的第一影响，如何优化启动时间一直都是个老生常谈的问题。本文结合了 WWDC16、WWDC17与WWDC19的相关 Session 与借鉴老司机的博客，梳理了启动阶段、dyld变化、Mach-O、虚拟内存等内容，简要阐述了如何优化与检测启动时间。</p><span id="more"></span><h2 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h2><h3 id="启动类型"><a href="#启动类型" class="headerlink" title="启动类型"></a>启动类型</h3><ul><li><p>冷启动</p><ul><li>重启后 / APP 很长时间为启动过</li><li>将它从磁盘加载到内存</li><li>启动支撑 APP 运行的系统侧服务(system-side service)</li><li>创建 APP 进程</li></ul></li><li><p>热启动</p><ul><li>APP 最近启动过</li><li>由于有APP部分与系统侧服务在内存中，所以会比冷启动快一些。</li></ul></li></ul><h3 id="启动阶段"><a href="#启动阶段" class="headerlink" title="启动阶段"></a>启动阶段</h3><ul><li><p>main 函数之前</p><ul><li><p>加载可执行文件</p></li><li><p>dyld 加载 dylibs，进行 rebase 指针调整 与 bind 符号绑定。</p><ul><li>rebase: 修正指向当前 Mach-O 文件的指针。所需要的指针信息已经被编码到 __LINKEDIT 里，然后就是不断重复的对 __DATA 的指针加上这个偏移量。</li><li>bind: 对调用外部符号进行绑定处理。</li></ul></li><li><p>Runtime 初始化</p></li></ul></li><li><p>main 函数之后</p><ul><li><p>实例化 UIApplication 与 UIApplicationDelegate </p></li><li><p>开始事件处理与系统集成</p></li><li><p>调用 UIApplicationDelegate 中生命周期方法</p><ul><li>普通：<br>application:willFinishLaunchingWithOptions:<br>application:didFinishLaunchingWithOptions:<br>applicationDidBecomeActive:</li><li>针对 UISceneDelegate：<br>application:willFinishLaunchingWithOptions:<br>application:didFinishLaunchingWithOptions:<br>scene:willConnectToSession:options:<br>sceneWillEnterForeground:<br>sceneDidBecomeActive:</li></ul></li><li><p>首屏渲染</p><ul><li>loadView</li><li>viewDidLoad</li><li>layoutSubViews</li></ul></li><li><p>异步获取数据并呈现给用户</p></li></ul></li></ul><h2 id="dyld"><a href="#dyld" class="headerlink" title="dyld"></a>dyld</h2><h3 id="dyld-1-x"><a href="#dyld-1-x" class="headerlink" title="dyld 1.x"></a>dyld 1.x</h3><ul><li>1996 - 2004</li><li>包含在 NeXTStep 3.0 中，不能很好支持相同语义同时一些边界条件无法正常运作。</li><li>预绑定(PreBuilding)：为 dylib 和 App 找到合适的固定地址，每次启动都会有。</li></ul><h3 id="dyld-2-x"><a href="#dyld-2-x" class="headerlink" title="dyld 2.x"></a>dyld 2.x</h3><ul><li><p>2004 - 2017</p></li><li><p>特性</p><ul><li><p>Codesign</p><ul><li>以页为单位，Mach-O 文件的每一页都要被 hash，在被载入时进行与  __LINKEDIT 中的信息进行校验。</li></ul></li><li><p>ASLR</p><ul><li>Mach-O 文件被加载到随机的地址上。</li></ul></li><li><p>Bounds Checking</p><ul><li>避免恶意的二进制文件的加入。</li></ul></li><li><p>Shared cache</p><ul><li>共享缓存是包含所有系统 dylib 的单个文件，代替了 PreBuilding。</li></ul></li></ul></li><li><p>流程</p><ul><li>解析 Mach-O 的 Header 与 Load Commands，递归加载其依赖的动态库。</li><li>映射所有 Mach-O 文件到 App 的地址空间。</li><li>符号查找</li><li>Rebase &amp; Bind</li><li>运行初始化程序</li></ul></li></ul><h3 id="dyld-3-x"><a href="#dyld-3-x" class="headerlink" title="dyld 3.x"></a>dyld 3.x</h3><ul><li><p>2017 - 至今</p></li><li><p>可缓存阶段 “解析Mach-O文件、找到对应依赖库、执行符号查找”，除了软件更新或者更改了磁盘上的库，负责每次启动的App依赖库符号不变、库中符号始终处于相同偏移量。因此将可缓存挪到了最前面，并将执行结果以闭包形式写入到磁盘。</p></li><li><p>dyld 被分为 3 个组件</p><ul><li>进程外的 Mach-O 解析器 / 编译器</li><li>进程内的引擎，用来启动闭包缓存</li><li>启动闭包缓存服务</li></ul></li><li><p>流程</p><ul><li>解析 Mach-O文件</li><li>找到所有依赖库</li><li>符号查找</li><li>读取启动闭包</li><li>验证启动闭包</li><li>映射 Mach-O 文件到 App的地址空间</li><li>Rebase &amp; Bind</li><li>运行初始化程序</li></ul></li></ul><h2 id="Mach-O"><a href="#Mach-O" class="headerlink" title="Mach-O"></a>Mach-O</h2><h3 id="Mach-O-是系统不同运行时期可执行文件的文件类型统称，主要分为-3-种"><a href="#Mach-O-是系统不同运行时期可执行文件的文件类型统称，主要分为-3-种" class="headerlink" title="Mach-O 是系统不同运行时期可执行文件的文件类型统称，主要分为 3 种"></a>Mach-O 是系统不同运行时期可执行文件的文件类型统称，主要分为 3 种</h3><ul><li>Executable：可执行文件，是 APP 中的主要 2 进制文件</li><li>Dylib：动态库，在其他平台也叫 DSO / DLL</li><li>Bundle：苹果平台特有的类型，是无法被链接的 Dylib。是能在运行时通过 dlopen() 加载</li></ul><h3 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h3><ul><li><p>Header：包含了 Mach-O 文件的基本信息。如：CPU 架构、文件类型、加载指令数量等</p></li><li><p>Load Commands：跟在 Header 后面的加载命令区，包含文件的组织架构、在虚拟内存的布局方式，在调用时知道如何设置和加载二进制文件。</p></li><li><p>Data：包含 Load Commands 中需要的各个  Segment 的数据。</p></li><li><p>绝大多数 Mach-O 包含以下三种类型的 Segment</p><ul><li>__TEXT：代码段，包含头文件、代码、常量。只读不可修改</li><li>__DATA：数据段，包含全局变量、静态变量。可读可写</li><li>__LINKEDIT：如何加载程序，包含方法和变量的元数据(位置、偏移量)，以及代码签名等信息。只读不可修改</li></ul></li></ul><h3 id="Mach-O-Universal-Files"><a href="#Mach-O-Universal-Files" class="headerlink" title="Mach-O Universal  Files"></a>Mach-O Universal  Files</h3><ul><li>支持多个架构的 Mach-O 文件通常被称为通用二进制文件，也称胖二进制文件。</li><li>胖二进制文件起始处有一个 Fat Header，包含所有的架构以及它们在文件中的偏移量。</li></ul><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><h3 id="虚拟内存是建立在物理内存和进程之间的中间层。是一个连续的逻辑地址空间，而且逻辑地址可以没有对应的实际物理地址，也可以让多个逻辑地址对应到同一个物理地址上。"><a href="#虚拟内存是建立在物理内存和进程之间的中间层。是一个连续的逻辑地址空间，而且逻辑地址可以没有对应的实际物理地址，也可以让多个逻辑地址对应到同一个物理地址上。" class="headerlink" title="虚拟内存是建立在物理内存和进程之间的中间层。是一个连续的逻辑地址空间，而且逻辑地址可以没有对应的实际物理地址，也可以让多个逻辑地址对应到同一个物理地址上。"></a>虚拟内存是建立在物理内存和进程之间的中间层。是一个连续的逻辑地址空间，而且逻辑地址可以没有对应的实际物理地址，也可以让多个逻辑地址对应到同一个物理地址上。</h3><h3 id="缺页中断-Page-Fault"><a href="#缺页中断-Page-Fault" class="headerlink" title="缺页中断(Page Fault)"></a>缺页中断(Page Fault)</h3><ul><li>当进程访问一个没有对应物理地址的逻辑地址时，会发生 Page Fault</li></ul><h3 id="懒加载-Lazy-Reading"><a href="#懒加载-Lazy-Reading" class="headerlink" title="懒加载(Lazy Reading)"></a>懒加载(Lazy Reading)</h3><ul><li>某个想要读取的页没有存在于内存会触发 Page Fault，系统通过 mmap() 函数读取指定页，这个过程成为 Lazy Reading。mmap() 函数可以将文件的部分内容映射到地址范围，而不是整个文件。</li></ul><h3 id="写时复制-Copy-On-Write"><a href="#写时复制-Copy-On-Write" class="headerlink" title="写时复制(Copy On Write)"></a>写时复制(Copy On Write)</h3><ul><li>当进程需要对某一页的内容进行修改时，内核会把需要修改的部分先复制一份，然后再修改，那个重新把逻辑地址映射到物理地址上去。</li></ul><h3 id="Dirty-Page-amp-Clean-Page"><a href="#Dirty-Page-amp-Clean-Page" class="headerlink" title="Dirty Page &amp; Clean Page"></a>Dirty Page &amp; Clean Page</h3><ul><li>Dirty Page：包含特定进程信息的页</li><li>Clean Page：不包含特定进程信息的页。如果需要，内核可以重新生成 Clean Page。</li></ul><h3 id="共享内存-Shared-RAM"><a href="#共享内存-Shared-RAM" class="headerlink" title="共享内存(Shared RAM)"></a>共享内存(Shared RAM)</h3><ul><li>当多个 Mach-O 依赖同一个 Dylib(eg. UIKit) 时，系统会让几个 Mach-O 的调用 Dylib 的逻辑地址指向同一块物理内存空间，从而实现内存共享。Dirty Page 为进程独有，不能被共享。</li></ul><h2 id="优化方式"><a href="#优化方式" class="headerlink" title="优化方式"></a>优化方式</h2><p>减少动态库或将多个动态库合并成一个</p><p>减少静态初始化</p><p>+load 方法内容放到首屏渲染后再执行，或使用 +initialize() 方法替换。</p><p>在 didFinishLaunchingWithOptions 和首屏渲染中只保留必要的初始化任务。</p><h2 id="如何检测"><a href="#如何检测" class="headerlink" title="如何检测"></a>如何检测</h2><p>hook</p><p>Instrument - App Lunch / 本地测量</p><p>Organizer - Launch Time / 线上数据</p><p>启动参数- DYLD_PRINT_STATISTICS=ture</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://xiaozhuanlan.com/topic/4690823715">老司机技术周报 - 优化 APP 启动</a></p><p><a href="https://developer.apple.com/videos/play/wwdc2019/423/">WWDC19 / 423 - 优化 APP 启动</a></p><p><a href="https://developer.apple.com/videos/play/wwdc2017/413">WWDC17 / 413 - App 启动时间: 过去、现在和将来</a></p><p><a href="https://huang-libo.github.io/posts/Optimizing-App-Startup-Time/#%E7%9B%AE%E5%BD%95">WWDC16 / 406 - 优化 App 启动时间</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;启动时间往往是一个用户对 APP 的第一影响，如何优化启动时间一直都是个老生常谈的问题。本文结合了 WWDC16、WWDC17与WWDC19的相关 Session 与借鉴老司机的博客，梳理了启动阶段、dyld变化、Mach-O、虚拟内存等内容，简要阐述了如何优化与检测启动时间。&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://xuhaodong1.github.io/categories/iOS/"/>
    
    
    <category term="App启动" scheme="https://xuhaodong1.github.io/tags/App%E5%90%AF%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>Swift 编译流程</title>
    <link href="https://xuhaodong1.github.io/2022/02/07/2022-02-07-Swift%20%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/"/>
    <id>https://xuhaodong1.github.io/2022/02/07/2022-02-07-Swift%20%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/</id>
    <published>2022-02-07T14:54:49.000Z</published>
    <updated>2022-12-20T13:01:35.264Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>书接上文，本文将介绍 <strong>Swift</strong> 语言的编译主要前端流程，后端的流程与上文同步，就不过多赘述，详情见 <a href="https://xuhaodong1.github.io/2021/11/03/2021-11-03-iOS%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/">iOS 编译过程</a>，同时本文就 <strong>SIL</strong> 介绍其特点。</p><span id="more"></span><h2 id="Clang-与-SwiftC"><a href="#Clang-与-SwiftC" class="headerlink" title="Clang 与 SwiftC"></a>Clang 与 SwiftC</h2><p>为什么要引入一种新的编译器，整体而言 <strong>Swift</strong> 作为一种高级语言，其很多高级特性 <strong>Clang</strong> 不支持，同时也由于 <strong>Clang</strong> 自身的一些弊端。进而催生出了 <strong>SwiftC</strong>，将 <strong>Clang</strong> 和 <strong>SwiftC</strong> 的编译流程进行对比：</p><p>其中 <strong>Clang</strong> 的劣势如下：</p><ul><li>语义不可重复表示，导致予以分析会依赖于 Parse(可看成生成 <strong>token</strong> 表，进行词法分析)。</li><li>IR 中间代码不适用于进行 <strong>Analysis</strong>，采用 <strong>CFG</strong> 进行分析，导致生成 <strong>IR</strong> 和 <strong>Analysis</strong> 是两部分 （Analysis 有别与词语分析与语法分析，它单独对源代码进行分析，如查找【不会执行的代码】、【不会被初始化的变量】、【静态分析】等）。</li><li>在 <strong>CFG</strong> 和 <strong>IR</strong> 降级的时候会做很多重复分析，做无用功。</li></ul><p>相较而言 <strong>Swift</strong> 解决了 <strong>Clang</strong> 中的很多问题，引入了 <strong>SIL</strong>（ <strong>Swift Intermediate Language</strong> ） 中间代码，既可进行 分析 又可进行 <strong>IR</strong> 代码生成，并引入了许多新的高级优化特性。</p><p><img src="/images/blog/webp.png" alt="img"></p><p><img src="/images/blog/Swift%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B.png" alt="img"></p><h2 id="SwiftC-编译流程-Frontend"><a href="#SwiftC-编译流程-Frontend" class="headerlink" title="SwiftC 编译流程(Frontend)"></a>SwiftC 编译流程(Frontend)</h2><h3 id="源码："><a href="#源码：" class="headerlink" title="源码："></a><strong>源码：</strong></h3><pre><code class="swift">class Person {    var name = "nihao"    func getName() -&gt; String {        print(name)        return name    }}</code></pre><h3 id="Parse-词法分析"><a href="#Parse-词法分析" class="headerlink" title="Parse(词法分析):"></a>Parse(词法分析):</h3><p>命令：<code>swiftc -dump-parse main.swift &gt;&gt; ./main.parse</code></p><pre><code class="shell">(source_file "main.swift"  (class_decl range=[main.swift:8:1 - line:15:1] "Person"    (pattern_binding_decl range=[main.swift:9:5 - line:9:16]      (pattern_named 'name')      Original init:      (string_literal_expr type='&lt;null&gt;' encoding=utf8 value="nihao" builtin_initializer=**NULL** initializer=**NULL**)      Processed init:      (string_literal_expr type='&lt;null&gt;' encoding=utf8 value="nihao" builtin_initializer=**NULL** initializer=**NULL**))    (var_decl range=[main.swift:9:9 - line:9:9] "name" type='&lt;null type&gt;')    (func_decl range=[main.swift:11:5 - line:14:5] "getName()"      (parameter "self")      (parameter_list range=[main.swift:11:17 - line:11:18])      (result        (type_ident          (component id='String' bind=none)))      (brace_stmt range=[main.swift:11:30 - line:14:5]        (call_expr type='&lt;null&gt;' arg_labels=_:          (unresolved_decl_ref_expr type='&lt;null&gt;' name=print function_ref=unapplied)          (paren_expr type='&lt;null&gt;'            (unresolved_decl_ref_expr type='&lt;null&gt;' name=name function_ref=unapplied)))        (return_stmt range=[main.swift:13:9 - line:13:16]          (unresolved_decl_ref_expr type='&lt;null&gt;' name=name function_ref=unapplied))))))</code></pre><p>可以看到有别于 Clang 生成 token 流的的形式，Parse阶段是一个递归至顶向下的解析过程，这也解释了其语义可重复表示的原因。</p><h3 id="语义分析并生成AST"><a href="#语义分析并生成AST" class="headerlink" title="语义分析并生成AST"></a>语义分析并生成AST</h3><p>命令：<code>swiftc -dump-ast main.swift &gt;&gt; ./main.ast</code></p><pre><code class="shell">(source_file "main.swift"  (class_decl range=[main.swift:8:1 - line:15:1] "Person" interface type='Person.Type' access=internal non-resilient    (pattern_binding_decl range=[main.swift:9:5 - line:9:16]      (pattern_named type='String' 'name')      Original init:      (string_literal_expr type='String' location=main.swift:9:16 range=[main.swift:9:16 - line:9:16] encoding=utf8 value="nihao" builtin_initializer=Swift.(file).String extension.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:) initializer=**NULL**)      Processed init:      (string_literal_expr type='String' location=main.swift:9:16 range=[main.swift:9:16 - line:9:16] encoding=utf8 value="nihao" builtin_initializer=Swift.(file).String extension.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:) initializer=**NULL**))    (var_decl range=[main.swift:9:9 - line:9:9] "name" type='String' interface type='String' access=internal readImpl=stored writeImpl=stored readWriteImpl=stored      (accessor_decl implicit range=[main.swift:9:9 - line:9:9] 'anonname=0x7fcbc202f0d8' interface type='(Person) -&gt; () -&gt; String' access=internal get_for=name        (parameter "self" type='Person' interface type='Person')        (parameter_list)        (brace_stmt implicit range=[main.swift:9:9 - line:9:9]          (return_stmt implicit            (member_ref_expr implicit type='String' decl=main.(file).Person.name@main.swift:9:9 direct_to_storage              (declref_expr implicit type='Person' decl=main.(file).Person.&lt;anonymous&gt;.self@main.swift:9:9 function_ref=unapplied)))))      (accessor_decl implicit range=[main.swift:9:9 - line:9:9] 'anonname=0x7fcbc202f330' interface type='(Person) -&gt; (String) -&gt; ()' access=internal set_for=name        (parameter "self" type='Person' interface type='Person')        (parameter_list range=[main.swift:9:9 - line:9:9]          (parameter "value" type='String' interface type='String'))......</code></pre><p>此步进行语法分析，并生成抽象语法树，可以看到生成的 AST 与 Parse 阶段的产于语法一直，不过在其基础上补充了很多内容，如类型、访问权限、构造函数、析构函数等。</p><h3 id="Raw-原始-SIL-生成"><a href="#Raw-原始-SIL-生成" class="headerlink" title="Raw(原始) SIL 生成"></a>Raw(原始) SIL 生成</h3><p>命令：<code>swiftc -emit-silgen main.swift &gt;&gt; ./main.silgen</code></p><pre><code class="swift">sil_stage rawimport Builtinimport Swiftimport SwiftShimsclass Person {  @_hasStorage @_hasInitialValue var name: String { get set }  func getName() -&gt; String  @objc deinit  init()}// mainsil [ossa] @main : $@convention(c) (Int32, UnsafeMutablePointer&lt;Optional&lt;UnsafeMutablePointer&lt;Int8&gt;&gt;&gt;) -&gt; Int32 {bb0(%0 : $Int32, %1 : $UnsafeMutablePointer&lt;Optional&lt;UnsafeMutablePointer&lt;Int8&gt;&gt;&gt;):  %2 = integer_literal $Builtin.Int32, 0          // user: %3  %3 = struct $Int32 (%2 : $Builtin.Int32)        // user: %4  return %3 : $Int32                              // id: %4} // end sil function 'main'// variable initialization expression of Person.namesil hidden [transparent] [ossa] @$s4main6PersonC4nameSSvpfi : $@convention(thin) () -&gt; @owned String {bb0:  %0 = string_literal utf8 "nihao"                // user: %5  %1 = integer_literal $Builtin.Word, 5           // user: %5  %2 = integer_literal $Builtin.Int1, -1          // user: %5  %3 = metatype $@thin String.Type                // user: %5  // function_ref String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)  %4 = function_ref @$sSS21_builtinStringLiteral17utf8CodeUnitCount7isASCIISSBp_BwBi1_tcfC : $@convention(method) (Builtin.RawPointer, Builtin.Word, Builtin.Int1, @thin String.Type) -&gt; @owned String // user: %5  %5 = apply %4(%0, %1, %2, %3) : $@convention(method) (Builtin.RawPointer, Builtin.Word, Builtin.Int1, @thin String.Type) -&gt; @owned String // user: %6  return %5 : $String                             // id: %6} // end sil function '$s4main6PersonC4nameSSvpfi'    ......</code></pre><p><strong>Raw SIL</strong>，由于 目前的 <strong>SIL</strong> 还未进行确保优化与诊断检查，此时的 <strong>SIL</strong> 还比较脆弱，所以称其为 <strong>Raw SIL</strong>。</p><h3 id="Canonical-正式-SIL生成"><a href="#Canonical-正式-SIL生成" class="headerlink" title="Canonical(正式) SIL生成"></a>Canonical(正式) SIL生成</h3><p>命令：<code>swiftc -emit-sil main.swift &gt;&gt; ./main.sil</code></p><pre><code class="Swift">sil_stage canonicalimport Builtinimport Swiftimport SwiftShimsclass Person {  @_hasStorage @_hasInitialValue var name: String { get set }  func getName() -&gt; String  @objc deinit  init()}// mainsil @main : $@convention(c) (Int32, UnsafeMutablePointer&lt;Optional&lt;UnsafeMutablePointer&lt;Int8&gt;&gt;&gt;) -&gt; Int32 {bb0(%0 : $Int32, %1 : $UnsafeMutablePointer&lt;Optional&lt;UnsafeMutablePointer&lt;Int8&gt;&gt;&gt;):  %2 = integer_literal $Builtin.Int32, 0          // user: %3  %3 = struct $Int32 (%2 : $Builtin.Int32)        // user: %4  return %3 : $Int32                              // id: %4} // end sil function 'main'// variable initialization expression of Person.namesil hidden [transparent] @$s4main6PersonC4nameSSvpfi : $@convention(thin) () -&gt; @owned String {bb0:  %0 = string_literal utf8 "nihao"                // user: %5  %1 = integer_literal $Builtin.Word, 5           // user: %5  %2 = integer_literal $Builtin.Int1, -1          // user: %5  %3 = metatype $@thin String.Type                // user: %5  // function_ref String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)  %4 = function_ref @$sSS21_builtinStringLiteral17utf8CodeUnitCount7isASCIISSBp_BwBi1_tcfC : $@convention(method) (Builtin.RawPointer, Builtin.Word, Builtin.Int1, @thin String.Type) -&gt; @owned String // user: %5  %5 = apply %4(%0, %1, %2, %3) : $@convention(method) (Builtin.RawPointer, Builtin.Word, Builtin.Int1, @thin String.Type) -&gt; @owned String // user: %6  return %5 : $String                             // id: %6} // end sil function '$s4main6PersonC4nameSSvpfi'// String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)sil [always_inline] [readonly] [_semantics "string.makeUTF8"] @$sSS21_builtinStringLiteral17utf8CodeUnitCount7isASCIISSBp_BwBi1_tcfC : $@convention(method) (Builtin.RawPointer, Builtin.Word, Builtin.Int1, @thin String.Type) -&gt; @owned String......</code></pre><p>这一步主要进行确保优化以及诊断检查工作：</p><p>特定流程：</p><ul><li><strong>强制内联</strong>：对于透明函数进行内联(透明函数：如果一个函数值受到入参的变化，每次调用相同的入参会有相同的返回值。)</li><li><strong>内存提升</strong>：1. 将<code>alloc_box</code>结构优化为<code>alloc_stack</code> 2. 提升无暴露地址(<code>non_address-exposed</code>)的<code>alloc_stack</code>说明到SSA注册。</li><li><strong>常数传播</strong>：一种优化常数手段，如表达式可以在编译器求值；常量值可代替常量变量；过程的部分参数是常量，减少涉及状态向量的大小可以避免代码的扩展等内容。具体可参考<a href="https://blog.csdn.net/qq_36287943/article/details/104974597">这里</a>。</li><li><strong>返回分析</strong>：验证每个方法在每个代码路径只返回一个值，并且不会在定义的末端出现无返回值的错误。</li><li><strong>临界拆分</strong>：不支持任意的基础block参数通过终端进行临界拆分，使得运算更加高效。</li></ul><h3 id="优化SIL"><a href="#优化SIL" class="headerlink" title="优化SIL"></a>优化SIL</h3><p>命令：<code>swiftc -emit-sil main.swift &gt;&gt; ./main.sil -O</code></p><p>也是在与上一步命令相同，但加上 -O参数，这一步不是必要的，如果在 <strong>Xcode</strong> 中设置 -Onone，则不会进行。</p><p>特定优化：</p><ul><li>泛型特化：分析泛型函数的特定调用，并生成新的特定版本的函数，将泛型的特定用法全部重写为对应的特定函数调用。</li><li><strong>witness</strong>和虚函数表的去虚拟化：通过给定类型去查找关联的类的虚函数表或者类型的witness表，并将虚函数调用替换为调用函数映射，简化了查找流程从而提高了效率。</li><li><strong>性能内联</strong></li><li><strong>引用计数优化</strong></li><li><strong>内存提升/优化</strong></li><li><strong>高级领域特定优化</strong>：swift编译器对基础的swift类型容器(类似Array或String)实现了高级优化，如 <strong>Copy On Wirte</strong>。</li></ul><h3 id="IR代码生成"><a href="#IR代码生成" class="headerlink" title="IR代码生成"></a>IR代码生成</h3><p>命令：<code>swiftc -emit-ir main.swift &gt;&gt; ./main.ir</code></p><pre><code class="swift">; ModuleID = '&lt;swift-imported-modules&gt;'source_filename = "&lt;swift-imported-modules&gt;"target datalayout = "e-m:o-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"target triple = "x86_64-apple-macosx12.0.0"%T4main6PersonC = type &lt;{ %swift.refcounted, %TSS }&gt;%swift.refcounted = type { %swift.type*, i64 }%swift.type = type { i64 }%TSS = type &lt;{ %Ts11_StringGutsV }&gt;%Ts11_StringGutsV = type &lt;{ %Ts13_StringObjectV }&gt;%Ts13_StringObjectV = type &lt;{ %Ts6UInt64V, %swift.bridge* }&gt;%Ts6UInt64V = type &lt;{ i64 }&gt;%swift.bridge = type opaque%swift.full_type = type { i8**, %swift.type }%objc_class = type { %objc_class*, %objc_class*, %swift.opaque*, %swift.opaque*, i64 }%swift.opaque = type opaque%swift.method_descriptor = type { i32, i32 }%swift.type_metadata_record = type { i32 }%swift.metadata_response = type { %swift.type*, i64 }%"$s4main6PersonC4nameSSvM.Frame" = type { [24 x i8] }%Any = type { [24 x i8], %swift.type* }%TSa = type &lt;{ %Ts12_ArrayBufferV }&gt;%Ts12_ArrayBufferV = type &lt;{ %Ts14_BridgeStorageV }&gt;%Ts14_BridgeStorageV = type &lt;{ %swift.bridge* }&gt;</code></pre><p>可以看到，生成的语法结构和 <strong>Objective-C</strong> 文件生成的结构一致。</p><p>至此，<strong>SwiftC</strong> 编译流程就已经全部梳理完了，其中还有 <strong>clang importer</strong> 模块的工作并未介绍，<strong>clang importer</strong> 负责导入 <strong>Clang</strong> 模块，并将 <strong>C</strong> 或 <strong>Objective-C</strong> 的API映射到 <strong>Swift API</strong> 中。</p><h2 id="SIL-介绍"><a href="#SIL-介绍" class="headerlink" title="SIL 介绍"></a>SIL 介绍</h2><p><strong>Swift</strong> 中间语言（Swift Intermediate Language，SIL）是一门高级且专用于 Swift 的中间语言，适用于对 Swift 代码的进一步分析和优化。SIL 依赖于 Swift 的类型系统和声明，所以 SIL 语法是 Swift 的延伸。一个 <code>.sil</code> 文件是一个增加了 SIL 定义的 Swift 源文件。 <code>.swift</code> 源文件只针对声明进行语法分析，其 <code>func</code> 方法体和最高阶代码将会被 SIL 语法分析器忽略。 在 <code>.sil</code> 文件中没有隐式 import。如果使用 swift 或者 Buildin 标准组件的话必须明确的引用。</p><h3 id="地址类型"><a href="#地址类型" class="headerlink" title="地址类型"></a>地址类型</h3><p>地址类型 <code>$*T</code> 指针指向的是任意引用的值或者 <code>$T</code>。地址不是引用计数指针，不能被 <code>retained</code> 或<code>released</code>。</p><h3 id="Box类型"><a href="#Box类型" class="headerlink" title="Box类型"></a>Box类型</h3><p>本地变量和非直接的数值类型都是存储在堆上，@box T 是一个引用计数类型，指向的是包含了多个 T 的盒子。盒子使用的是 Swift 的原生引用计数。</p><h3 id="Metatype-类型"><a href="#Metatype-类型" class="headerlink" title="Metatype 类型"></a>Metatype 类型</h3><p>SIL 内的 <code>metatype</code> 类型必须描述自身表示：</p><ul><li><code>@thin</code> 表示不需要内存空间</li><li><code>@thick</code> 指存储的是类型的引用或者类型子类的引用</li><li><code>@objc</code> 指存储的是一个 OC 类对象的表示。</li></ul><h3 id="VTables"><a href="#VTables" class="headerlink" title="VTables"></a>VTables</h3><p>用来表示类对象方法的动态派发，如果看到 SIL 代码中出现 <code>class_method</code> 或者 <code>super_method</code>，这些都是通过 <code>sil_vtable</code> 进行追踪的；<code>sil_table</code> 中包含类对象中的所有方法的映射，包括从父对象继承的方法。</p><h3 id="Witness-Table"><a href="#Witness-Table" class="headerlink" title="Witness Table"></a>Witness Table</h3><p>用来代表泛型类型的方法动态派发，一个泛型类型的所有的所有泛型实例共享一个 <code>Witness Table</code>，同样衍生类也都会集成基类的 <code>Witness Table</code>。</p><p>每个遵循协议的对象都会有一个唯一标识，会生成一张 <code>Witness table</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文梳理了 Swift 的编译流程，可以看出，Swift 作为一种高级的安全类型语言，编译器对其做了许多优化，算是弥补了对 Clang 许多不足。SIL 是 Swift 编译的重点，从中可以窥探一些平时开发中难以琢磨的问题，如方法派发、引用计数等内容。以下附swiftc 的命令行帮助。</p><pre><code class="shell">USAGE: swiftcMODES:  -dump-ast               Parse and type-check input file(s) and dump AST(s)  -dump-parse             Parse input file(s) and dump AST(s)  -dump-pcm               Dump debugging information about a precompiled Clang module  -dump-scope-maps &lt;expanded-or-list-of-line:column&gt;                          Parse and type-check input file(s) and dump the scope map(s)  -dump-type-info         Output YAML dump of fixed-size types from all imported modules  -dump-type-refinement-contexts                          Type-check input file(s) and dump type refinement contexts(s)  -emit-assembly          Emit assembly file(s) (-S)  -emit-bc                Emit LLVM BC file(s)  -emit-executable        Emit a linked executable  -emit-imported-modules  Emit a list of the imported modules  -emit-irgen             Emit LLVM IR file(s) before LLVM optimizations  -emit-ir                Emit LLVM IR file(s) after LLVM optimizations  -emit-library           Emit a linked library  -emit-object            Emit object file(s) (-c)  -emit-pcm               Emit a precompiled Clang module from a module map  -emit-sibgen            Emit serialized AST + raw SIL file(s)  -emit-sib               Emit serialized AST + canonical SIL file(s)  -emit-silgen            Emit raw SIL file(s)  -emit-sil               Emit canonical SIL file(s)  -emit-supported-features                          Emit a JSON file including all supported compiler features  -index-file             Produce index data for a source file  -parse                  Parse input file(s)  -print-ast              Parse and type-check input file(s) and pretty print AST(s)  -resolve-imports        Parse and resolve imports in input file(s)  -scan-dependencies      Scan dependencies of the given Swift sources  -typecheck              Parse and type-check input file(s)</code></pre><p>🔗：</p><p><a href="https://www.jianshu.com/p/c2880460c6cd">Swift的高级中间语言：SIL</a></p><p><a href="https://www.swift.org/swift-compiler/">Swift-Compiler 官方</a></p><p><a href="https://zhuanlan.zhihu.com/p/353732257">Swift - 源码编译</a></p><p><a href="https://blog.csdn.net/qq_36287943/article/details/104974597">编译优化之 - 常数传播入门</a></p><p><a href="https://github.com/apple/swift/blob/2ddc92a51a4c6d216a9b2dc3a2e41e9b592afbdf/docs/SIL.rst">Apple - Swift Intermediate Language</a></p><p><a href="https://blog.csdn.net/Hello_Hwc/article/details/85226147">深入浅出iOS编译</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;书接上文，本文将介绍 &lt;strong&gt;Swift&lt;/strong&gt; 语言的编译主要前端流程，后端的流程与上文同步，就不过多赘述，详情见 &lt;a href=&quot;https://xuhaodong1.github.io/2021/11/03/2021-11-03-iOS%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/&quot;&gt;iOS 编译过程&lt;/a&gt;，同时本文就 &lt;strong&gt;SIL&lt;/strong&gt; 介绍其特点。&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://xuhaodong1.github.io/categories/iOS/"/>
    
    
    <category term="Compile" scheme="https://xuhaodong1.github.io/tags/Compile/"/>
    
    <category term="Swift" scheme="https://xuhaodong1.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>iOS 编译过程</title>
    <link href="https://xuhaodong1.github.io/2021/11/03/2021-11-03-iOS%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/"/>
    <id>https://xuhaodong1.github.io/2021/11/03/2021-11-03-iOS%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/</id>
    <published>2021-11-03T14:54:49.000Z</published>
    <updated>2022-12-20T13:01:35.260Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学习 <strong>iOS</strong> 编译过程（<strong>Compile</strong>）有助于我们更好理解代码是如何被计算机运作起来，编译器为代码做了哪些优化，让我们学会从另一个角度来看待问题。</p><span id="more"></span><h2 id="编译器结构"><a href="#编译器结构" class="headerlink" title="编译器结构"></a>编译器结构</h2><p>现代编译器是将源代码转换成可执行文件的程序，工作流程主要分为 <strong>前端</strong> 和 <strong>后端</strong> 两个部分：</p><ol><li>前端：对源代码进行解析，并生成中间代码。</li><li>后端：针对中间代码进行优化，并转换成目标机器的代码指令。</li></ol><pre class="mermaid">graph LR    A(SourceCode) --&gt; B(Frontend)    B(Frontend) --&gt; C(Backend)    C(Backend) --&gt; D(Machine Code)</pre><p>针对iOS平台，不同语言采用了不同的编译器前端：</p><ol><li><p><strong>Frontend：Clang / SwiftC</strong></p><p>对于 <strong>Objective-C / C / C++ / Objective-C++</strong>  来说采用 <strong>Clang</strong> 编译器前端；</p><p>对于 <strong>Swift</strong> 来说则采用 <strong>SwiftC</strong>；</p></li><li><p><strong>Backend：LLVM</strong></p><p>无论是 <strong>C</strong> 系语言还是 <strong>Swift</strong> 都采用 <strong>LLVM</strong> 作为编译器后端；</p></li></ol><p>值得注意的是在 <strong>Xcode3</strong> 以前，都采用 <strong>GCC</strong> 作为编译器前端，但为 <strong>Apple</strong> 快速发展需要功能更强大和性能更好的编译器，所以 <strong>Apple</strong> 自己开发了 <strong>Clang</strong> 作为编译器前端。下面对编译器做一个简要介绍：</p><ul><li><strong>GCC</strong></li></ul><p><strong>GCC</strong>（<strong>GNU Compile Collection</strong>，**GNU **编译器套装），是一套由 <strong>GNU</strong> 开发的编程语言编译器。来本只能处理 <em>C</em> 语言，后来快速演进，变得可处理 <strong>C++、Objective-C、Java、Fortran</strong> 等其他语言。但由于一些缺陷，导致了 <strong>Apple</strong> 抛弃了 <strong>GCC</strong> ，开发出了 <strong>Clang</strong> 作为其前端编译器。</p><ol><li><strong>GCC</strong> 的 <strong>Objective-C Frontend</strong> 不是 <strong>Apple</strong> 维护，导致想要添加一些语法提示等功能得去要求 <strong>GCC</strong> 团队做。</li><li><strong>GCC</strong> 的插件、工具、<strong>IDE</strong> 的支持薄弱。</li><li><strong>GCC</strong> 的编译效率和性能不足。</li></ol><ul><li><strong>Clang</strong></li></ul><p><strong>Clang1.0</strong> 于 <strong>2009</strong> 年正式与 <strong>LLVM2.6</strong> 正式发布，旨在提供 <strong>GCC</strong> 的替代品，支持了 <strong>GUN</strong> 编译器大多数的编译器设置以及非官方语言的拓展，相较于 <strong>GCC</strong> ，<strong>Clang</strong> 具有以下优势：</p><ol><li>编译速度更快。</li><li>占用内存更小。</li><li>模块化设计，易于拓展与重用。</li><li>诊断信息可读性强。</li></ol><ul><li><strong>SwiftC</strong></li></ul><p><strong>SwiftC</strong> 在前端采用了 <strong>SIL</strong> 中间语言，这是因为 <strong>Swift</strong> 作为一种高级语言，有许多特性，如 <strong>protocol</strong> 的泛型，也是一门安全的语言，确保变量在使用之前被初始化、检测不可执行的代码，于是增加了一层 <strong>SIL</strong> 来做这些事情。</p><ul><li><strong>LLVM</strong></li></ul><p><strong>LLVM</strong> 是一套编译器基础设备项目，由 <strong>C++</strong> 写成，包含一系列模块化的编译器组件和工具链，用来开发编译器的前端和后端。在 <strong>iOS</strong> 中，<strong>LLVM</strong> 作为编译器后端主要提供 <strong>Optimizer</strong> 和 <strong>Code Generator</strong> ，将接收到的 <strong>IR</strong> 中间代码进行优化，以及机器代码生成。</p><h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><h3 id="流程梳理"><a href="#流程梳理" class="headerlink" title="流程梳理"></a>流程梳理</h3><pre class="mermaid">graph TD    subgraph Clang    id1(源代码) --&gt; id2(预处理)     id2(预处理) --&gt; id3(语法分析)       id3(词法分析) --  token  --&gt; id4(语法分析)    id4(语法分析) --  AST  --&gt; id5(中间代码生成)    end        subgraph Optimizer, Backend    id6(中间代码优化) --&gt; id7(BitCode生成)    id7(BitCode生成) --&gt; id8(汇编指令生成)    id8(汇编指令生成) --&gt; id9(机器码生成)    id9(机器码生成) --&gt; id11(链接生成可执行文件)    end        subgraph SwiftC    id12(源代码) --&gt; id13(解析)    id13(解析) --&gt; id14(语义分析)    id14(语义分析) --&gt; id16(Raw SIL生成)    id16(Raw SIL生成) --&gt; id17(Canonical SIL生成)    id17 --&gt; id18(SIL优化)    id18(SIL优化) --&gt; id19(中间代码生成)    end        id5 --  IR  --&gt; id6    id19 --  IR  --&gt; id6</pre><p>在前端 <strong>Objective-C</strong> 和 <strong>Swift</strong> 分别由自己的处理阶段，但最后都会生成 <strong>IR</strong> 中间代码，交由后端进行统一处理。</p><p>下面我们从一个简单的.m文件进行编译过程梳理，首先在某一个目录下创建一个 <strong>nihao.m</strong>文件</p><pre><code class="shell">touch nihao.m</code></pre><p><strong>nihao.m：</strong></p><pre><code class="objective-c">#import &lt;Foundation/Foundation.h&gt;int main(int argc, char *argv[]){    @autoreleasepool {        NSLog(@"nihao!!!");        return 0;    }}</code></pre><h3 id="Clang阶段（Objective-C-C-C-Objective-C-）"><a href="#Clang阶段（Objective-C-C-C-Objective-C-）" class="headerlink" title="Clang阶段（Objective-C / C++ / C / Objective-C++）"></a>Clang阶段（Objective-C / C++ / C / Objective-C++）</h3><h4 id="预处理阶段："><a href="#预处理阶段：" class="headerlink" title="预处理阶段："></a>预处理阶段：</h4><pre><code class="shell">xcrun clang -E helloworld.c | open -f</code></pre><pre><code># 1 "nihao.m"# 1 "&lt;built-in&gt;" 1# 1 "&lt;built-in&gt;" 3# 380 "&lt;built-in&gt;" 3# 1 "&lt;command line&gt;" 1# 1 "&lt;built-in&gt;" 2# 1 "nihao.m" 2# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/System/Library/Frameworks/Foundation.framework/Headers/Foundation.h" 1 3.........int main(int argc, char *argv[]){    @autoreleasepool {        NSLog(@"nihao!!!");        return 0;    }}</code></pre><p>将预处理阶段输出到文件， 可以看到很多以 <strong>#</strong> 开头的语句，这些语句告诉我们后面跟着的内容来自哪里，这里可以看见 <strong>Foundation.h</strong> 文件的内容也包含了进来。在 <strong>Xcode</strong> 中，也可以通过 <strong>Product -&gt;  Perfrom Action -&gt; Preprocess</strong> 查看预处理阶段之后的代码。在预处理阶段做了以下这些事情：</p><ul><li>将头文件引入的其他文件加入源文件中，是一个递归的过程。</li><li>进行条件编译处理。</li><li>将宏定义直接替换，不进行语法检查。</li><li>将注释进行删除处理。</li></ul><h4 id="词法分析阶段"><a href="#词法分析阶段" class="headerlink" title="词法分析阶段"></a>词法分析阶段</h4><pre><code class="shell">xcrun clang -fmodules -fsyntax-only -Xclang -dump-tokens nihao.m</code></pre><pre><code>annot_module_include '#import &lt;Foundation/Foundation.h&gt;'        Loc=&lt;nihao.m:1:1&gt;int 'int'     [StartOfLine]    Loc=&lt;nihao.m:3:1&gt;identifier 'main'     [LeadingSpace]    Loc=&lt;nihao.m:3:5&gt;l_paren '('        Loc=&lt;nihao.m:3:9&gt;int 'int'        Loc=&lt;nihao.m:3:10&gt;identifier 'argc'     [LeadingSpace]    Loc=&lt;nihao.m:3:14&gt;comma ','        Loc=&lt;nihao.m:3:18&gt;char 'char'     [LeadingSpace]    Loc=&lt;nihao.m:3:20&gt;star '*'     [LeadingSpace]    Loc=&lt;nihao.m:3:25&gt;identifier 'argv'        Loc=&lt;nihao.m:3:26&gt;l_square '['        Loc=&lt;nihao.m:3:30&gt;r_square ']'        Loc=&lt;nihao.m:3:31&gt;r_paren ')'        Loc=&lt;nihao.m:3:32&gt;l_brace '{'     [StartOfLine]    Loc=&lt;nihao.m:4:1&gt;at '@'     [StartOfLine] [LeadingSpace]    Loc=&lt;nihao.m:5:5&gt;identifier 'autoreleasepool'        Loc=&lt;nihao.m:5:6&gt;...</code></pre><p>词法分析阶段其实是将源代码以字符文本的形式转换成 <strong>Token</strong> 流的形式，不涉及语义校验，用来标识出这个字符是标识符、括号、if语句…，最后还会标识出其所在位置，方便后续分析能够找出出错的原始位置。</p><h4 id="语法分析阶段"><a href="#语法分析阶段" class="headerlink" title="语法分析阶段"></a>语法分析阶段</h4><pre><code>xcrun clang -fsyntax-only -Xclang -ast-dump nihao.m | open -f</code></pre><pre><code>...`-FunctionDecl 0x7f9eb4bd61a0 &lt;nihao.m:3:1, line:9:1&gt; line:3:5 main 'int (int, char **)'  |-ParmVarDecl 0x7f9eb4bd5fc0 &lt;col:10, col:14&gt; col:14 argc 'int'  |-ParmVarDecl 0x7f9eb4bd6080 &lt;col:20, col:31&gt; col:26 argv 'char **':'char **'  `-CompoundStmt 0x7f9eb4bd63d0 &lt;line:4:1, line:9:1&gt;    `-ObjCAutoreleasePoolStmt 0x7f9eb4bd63b8 &lt;line:5:5, line:8:5&gt;      `-CompoundStmt 0x7f9eb4bd6398 &lt;line:5:22, line:8:5&gt;        |-CallExpr 0x7f9eb4bd6328 &lt;line:6:9, col:26&gt; 'void'        | |-ImplicitCastExpr 0x7f9eb4bd6310 &lt;col:9&gt; 'void (*)(id, ...)' &lt;FunctionToPointerDecay&gt;        | | `-DeclRefExpr 0x7f9eb4bd6250 &lt;col:9&gt; 'void (id, ...)' Function 0x7f9eb0c8d6c8 'NSLog' 'void (id, ...)'        | `-ImplicitCastExpr 0x7f9eb4bd6350 &lt;col:15, col:16&gt; 'id':'id' &lt;BitCast&gt;        |   `-ObjCStringLiteral 0x7f9eb4bd6290 &lt;col:15, col:16&gt; 'NSString *'        |     `-StringLiteral 0x7f9eb4bd6270 &lt;col:16&gt; 'char [9]' lvalue "nihao!!!"        `-ReturnStmt 0x7f9eb4bd6388 &lt;line:7:9, col:16&gt;          `-IntegerLiteral 0x7f9eb4bd6368 &lt;col:16&gt; 'int' 0</code></pre><p>语法分析阶段会输出 <strong>AST</strong>（抽象语法树），它是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。通过它，可以进行语法错误分析，以及静态分析操作，涵盖内存操作和安全等方面。</p><h4 id="CodeGen阶段"><a href="#CodeGen阶段" class="headerlink" title="CodeGen阶段"></a>CodeGen阶段</h4><pre><code class="shell">xcrun clang -S -fobjc-arc -emit-llvm nihao.m -o nihao.ll</code></pre><pre><code>; ModuleID = 'nihao.m'source_filename = "nihao.m"target datalayout = "e-m:o-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"target triple = "x86_64-apple-macosx11.0.0"%struct.__NSConstantString_tag = type { i32*, i32, i8*, i64 }@__CFConstantStringClassReference = external global [0 x i32]@.str = private unnamed_addr constant [9 x i8] c"nihao!!!\00", section "__TEXT,__cstring,cstring_literals", align 1@_unnamed_cfstring_ = private global %struct.__NSConstantString_tag { i32* getelementptr inbounds ([0 x i32], [0 x i32]* @__CFConstantStringClassReference, i32 0, i32 0), i32 1992, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str, i32 0, i32 0), i64 8 }, section "__DATA,__cfstring", align 8 #0; Function Attrs: noinline optnone ssp uwtabledefine i32 @main(i32 %0, i8** %1) #1 {  %3 = alloca i32, align 4  %4 = alloca i32, align 4  %5 = alloca i8**, align 8  store i32 0, i32* %3, align 4  store i32 %0, i32* %4, align 4  store i8** %1, i8*** %5, align 8  %6 = call i8* @llvm.objc.autoreleasePoolPush() #2  notail call void (i8*, ...) @NSLog(i8* bitcast (%struct.__NSConstantString_tag* @_unnamed_cfstring_ to i8*))  store i32 0, i32* %3, align 4  call void @llvm.objc.autoreleasePoolPop(i8* %6)  %7 = load i32, i32* %3, align 4  ret i32 %7}; Function Attrs: nounwinddeclare i8* @llvm.objc.autoreleasePoolPush() #2declare void @NSLog(i8*, ...) #3; Function Attrs: nounwinddeclare void @llvm.objc.autoreleasePoolPop(i8*) #2attributes #0 = { "objc_arc_inert" }attributes #1 = { noinline optnone ssp uwtable "darwin-stkchk-strong-link" "disable-tail-calls"="false" "frame-pointer"="all" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "probe-stack"="___chkstk_darwin" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+cx8,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "tune-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }attributes #2 = { nounwind }attributes #3 = { "darwin-stkchk-strong-link" "disable-tail-calls"="false" "frame-pointer"="all" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "probe-stack"="___chkstk_darwin" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+cx8,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "tune-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }!llvm.module.flags = !{!0, !1, !2, !3, !4, !5, !6, !7}!llvm.ident = !{!8}!0 = !{i32 2, !"SDK Version", [2 x i32] [i32 12, i32 0]}!1 = !{i32 1, !"Objective-C Version", i32 2}!2 = !{i32 1, !"Objective-C Image Info Version", i32 0}!3 = !{i32 1, !"Objective-C Image Info Section", !"__DATA,__objc_imageinfo,regular,no_dead_strip"}!4 = !{i32 1, !"Objective-C Garbage Collection", i8 0}!5 = !{i32 1, !"Objective-C Class Properties", i32 64}!6 = !{i32 1, !"wchar_size", i32 4}!7 = !{i32 7, !"PIC Level", i32 2}!8 = !{!"Apple clang version 13.0.0 (clang-1300.0.29.3)"}</code></pre><p><strong>CodeGen</strong> 阶段负责将 <strong>AST</strong> 自顶向下遍历逐步翻译成 <strong>LLVM IR</strong>，也就是编译器后端所需要的中间代码，同时 <strong>Objective-C</strong> 代码也会在这一步进行 <strong>Runtime</strong> 桥接： <strong>property</strong> 合成，<strong>ARC</strong> 处理等，如上方可以看见 <strong>autoreleasePoolPush</strong> 、 <strong>autoreleasePoolPop</strong> 操作。</p><p>至此 <strong>Clang</strong> 前端工作算是完成，接下来就交给后端进行处理。</p><h3 id="LLVM-Optimizer-阶段"><a href="#LLVM-Optimizer-阶段" class="headerlink" title="LLVM Optimizer 阶段"></a>LLVM Optimizer 阶段</h3><h4 id="IR代码优化"><a href="#IR代码优化" class="headerlink" title="IR代码优化"></a>IR代码优化</h4><pre><code class="shell">xcrun clang -Os -S -fobjc-arc -emit-llvm nihao.m -o nihao.ll</code></pre><pre><code>; ModuleID = 'nihao.m'source_filename = "nihao.m"target datalayout = "e-m:o-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"target triple = "x86_64-apple-macosx11.0.0"%struct.__NSConstantString_tag = type { i32*, i32, i8*, i64 }@__CFConstantStringClassReference = external global [0 x i32]@.str = private unnamed_addr constant [9 x i8] c"nihao!!!\00", section "__TEXT,__cstring,cstring_literals", align 1@_unnamed_cfstring_ = private global %struct.__NSConstantString_tag { i32* getelementptr inbounds ([0 x i32], [0 x i32]* @__CFConstantStringClassReference, i32 0, i32 0), i32 1992, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str, i32 0, i32 0), i64 8 }, section "__DATA,__cfstring", align 8 #0; Function Attrs: optsize ssp uwtabledefine i32 @main(i32 %0, i8** nocapture readnone %1) local_unnamed_addr #1 {  %3 = tail call i8* @llvm.objc.autoreleasePoolPush() #2  notail call void (i8*, ...) @NSLog(i8* bitcast (%struct.__NSConstantString_tag* @_unnamed_cfstring_ to i8*)) #4, !clang.arc.no_objc_arc_exceptions !9  tail call void @llvm.objc.autoreleasePoolPop(i8* %3) #2  ret i32 0}; Function Attrs: nounwinddeclare i8* @llvm.objc.autoreleasePoolPush() #2; Function Attrs: optsizedeclare void @NSLog(i8*, ...) local_unnamed_addr #3; Function Attrs: nounwinddeclare void @llvm.objc.autoreleasePoolPop(i8*) #2attributes #0 = { "objc_arc_inert" }attributes #1 = { optsize ssp uwtable "darwin-stkchk-strong-link" "disable-tail-calls"="false" "frame-pointer"="all" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "probe-stack"="___chkstk_darwin" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+cx8,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "tune-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }attributes #2 = { nounwind }attributes #3 = { optsize "darwin-stkchk-strong-link" "disable-tail-calls"="false" "frame-pointer"="all" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "probe-stack"="___chkstk_darwin" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+cx8,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "tune-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }attributes #4 = { optsize }!llvm.module.flags = !{!0, !1, !2, !3, !4, !5, !6, !7}!llvm.ident = !{!8}!0 = !{i32 2, !"SDK Version", [2 x i32] [i32 12, i32 0]}!1 = !{i32 1, !"Objective-C Version", i32 2}!2 = !{i32 1, !"Objective-C Image Info Version", i32 0}!3 = !{i32 1, !"Objective-C Image Info Section", !"__DATA,__objc_imageinfo,regular,no_dead_strip"}!4 = !{i32 1, !"Objective-C Garbage Collection", i8 0}!5 = !{i32 1, !"Objective-C Class Properties", i32 64}!6 = !{i32 1, !"wchar_size", i32 4}!7 = !{i32 7, !"PIC Level", i32 2}!8 = !{!"Apple clang version 13.0.0 (clang-1300.0.29.3)"}!9 = !{}</code></pre><p><strong>IR</strong> 代码优化会调用相应 <strong>Pass</strong> 进行处理，<strong>Pass</strong> 由多个节点组成，都是 <strong>Pass</strong> 类的子类，每个节点负责特定的优化。这使得我们能够自主的控制优化的强度，在<strong>Build Strrings -&gt; Optimization Level</strong> 中可指定优化程度，一些常见的代码优化方法如下：</p><ul><li>删除公共子表达式</li><li>删除无用代码</li><li>常量合并</li><li>代码移动</li><li>删除归纳变量</li></ul><h4 id="生成-BitCode（Archive时）"><a href="#生成-BitCode（Archive时）" class="headerlink" title="生成 BitCode（Archive时）"></a>生成 BitCode（Archive时）</h4><pre><code class="shell">xrun clang -emit-llvm -c nihao.m -o nihao.bc</code></pre><pre><code>dec0 170b 0000 0000 1400 0000 0010 00000700 0001 4243 c0de 3514 0000 0700 0000620c 3024 9596 a6a5 f7d7 7f7d d3b4 4ffb76ef df3f 2d44 0132 0500 0000 210c 00004903 0000 0b02 2100 0200 0000 1600 00000781 2391 41c8 0449 0610 3239 9201 840c2505 0819 1e04 8b62 8014 4502 4292 0b42a410 3214 3808 184b 0a32 5288 4870 c421...</code></pre><p><strong>BitCode</strong> 是 <strong>LLVM</strong> 引入的另一种中间代码，虽然看起来比较接近机器码，但是在函数和指令层面使用了很多高级语言的特性。</p><p>但只会在 <strong>Archive</strong> 时，<strong>BitCode</strong> 才会被嵌入到链接后的二进制文件，用于提交给 <strong>App Store</strong>，包含 <strong>Bitcode</strong> 配置的程序将会在 <strong>App Store</strong> 上被重新编译和链接，进而对可执行文件做优化。值得注意的是，优化这一步是在 <strong>App Store</strong> 中做的处理，本地没有做处理。进行其他类型的 <strong>Build</strong> (非 <strong>Archive</strong> )时，编译器只会检查是否满足开启 <strong>BitCode</strong> 的条件，但并不会真正生成 <strong>BitCode</strong> 。</p><h3 id="LLVM-Code-Generator阶段"><a href="#LLVM-Code-Generator阶段" class="headerlink" title="LLVM Code Generator阶段"></a>LLVM Code Generator阶段</h3><h4 id="生成汇编代码"><a href="#生成汇编代码" class="headerlink" title="生成汇编代码"></a>生成汇编代码</h4><pre><code class="shell">xcrun clang -S -fobjc-arc nihao.m -o nihao.s</code></pre><pre><code>    .section    __TEXT,__text,regular,pure_instructions    .build_version macos, 11, 0    sdk_version 12, 0    .globl    _main                           ## -- Begin function main    .p2align    4, 0x90_main:                                  ## @main    .cfi_startproc## %bb.0:    pushq    %rbp    .cfi_def_cfa_offset 16    .cfi_offset %rbp, -16    movq    %rsp, %rbp    .cfi_def_cfa_register %rbp    subq    $32, %rsp    movl    $0, -4(%rbp)    movl    %edi, -8(%rbp)    movq    %rsi, -16(%rbp)    callq    _objc_autoreleasePoolPush    movq    %rax, -24(%rbp)                 ## 8-byte Spill    leaq    L__unnamed_cfstring_(%rip), %rdi    movb    $0, %al    callq    _NSLog    movq    -24(%rbp), %rdi                 ## 8-byte Reload    movl    $0, -4(%rbp)    callq    _objc_autoreleasePoolPop    movl    -4(%rbp), %eax    addq    $32, %rsp    popq    %rbp    retq    .cfi_endproc                                        ## -- End function    .section    __TEXT,__cstring,cstring_literalsL_.str:                                 ## @.str    .asciz    "nihao!!!"    .section    __DATA,__cfstring    .p2align    3                               ## @_unnamed_cfstring_L__unnamed_cfstring_:    .quad    ___CFConstantStringClassReference    .long    1992                            ## 0x7c8    .space    4    .quad    L_.str    .quad    8                               ## 0x8    .section    __DATA,__objc_imageinfo,regular,no_dead_stripL_OBJC_IMAGE_INFO:    .long    0    .long    64.subsections_via_symbols</code></pre><p>汇编语言更加接近机器语言，能够直接对硬件进行操作，生成的程序与其他的语言相比具有更高的运行速度，占用更小的内存。</p><p>目前所有 <strong>iOS</strong> 设备都采用 <strong>ARM</strong> 处理器，这意味着都是采用 <strong>ARM</strong> 指令集，如 <strong>armv6 / armv7 / armv7s / arm64</strong>，这些指令集都是向下兼容的。</p><p>每种 <strong>CPU</strong> 架构都有着相应的指令集，可以针对不同的架构产生不同的汇编指令，加上上面 <strong>- arch arch_type</strong> 选项即可，更多请参见<a href="https://developer.apple.com/library/archive/documentation/DeveloperTools/Reference/Assembler/000-Introduction/introduction.html">官网</a>。在 <strong>Xcode</strong> 中可在 <strong>Build Settings -&gt; Architectrues</strong> 指定产生的 <strong>CPU</strong> 指令集。</p><h4 id="生成机器代码"><a href="#生成机器代码" class="headerlink" title="生成机器代码"></a>生成机器代码</h4><pre><code class="shell">xcrun clang -fmodules -c nihao.s -o nihao.o</code></pre><p>可以发现机器码二进制文件无法阅读，可借助 <strong>otool</strong> 或者 <strong>MachOView</strong> 等工具查看文件中的相关内容：</p><pre><code class="shell">otool -v -h nihao.o</code></pre><pre><code>nihao.o:Mach header      magic  cputype cpusubtype  caps    filetype ncmds sizeofcmds      flagsMH_MAGIC_64   X86_64        ALL  0x00      OBJECT     4        680 SUBSECTIONS_VIA_SYMBOLS</code></pre><p>可以看见 <strong>.o</strong> 文件实际上是 <strong>mach-o</strong> 格式，这里我们输入可执行文件的头部，规定了这个文件是什么，适应架构的相关信息，以及文件是如何被加载的。更多关于 <strong>mach-o</strong> 的知识<a href="https://www.jianshu.com/p/54d842db3f69">参见</a>。</p><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><pre><code class="shell">xcrun clang nihao.o -Wl,`xcrun --show-sdk-path`/System/Library/Frameworks/Foundation.framework/Foundation</code></pre><pre><code class="shell">./a.out</code></pre><pre><code>2021-11-03 16:06:41.734 a.out[6394:220026] nihao!!!</code></pre><p>由于我们引入了 <strong>Foundation</strong> 里面的文件，所以需要将目标文件和 <strong>Foundation framework</strong>进行链接，接着就可以运行我们的程序了。</p><p>这里涉及到一个概念：符号表，里面存储的元素如下：</p><pre><code class="xml">&lt;起始地址&gt; &lt;结束地址&gt; &lt;函数&gt; [&lt;文件名:行号&gt;]</code></pre><p>这里我们输入a.out的符号信息</p><pre><code>nm -nm a.out</code></pre><pre><code>                 (undefined) external _NSLog (from Foundation)                 (undefined) external ___CFConstantStringClassReference (from CoreFoundation)                 (undefined) external _objc_autoreleasePoolPop (from libobjc)                 (undefined) external _objc_autoreleasePoolPush (from libobjc)                 (undefined) external dyld_stub_binder (from libSystem)0000000100000000 (__TEXT,__text) [referenced dynamically] external __mh_execute_header0000000100003f20 (__TEXT,__text) external _main0000000100008018 (__DATA,__data) non-external __dyld_private</code></pre><p>对于动态链接库的符号（如 <strong>Foundation</strong>），最终会记录下这个符号是通过进行链接的，并记录下依赖于哪个动态链接库。在运行时，动态链接器（<strong>dyld</strong>）会去解析这些 <strong>undefined</strong> 符号。对于其他位置的符号，会直接修正这些符号的具体位置信息。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了关于 iOS 编译器、iOS 编译过程的基础知识。学习了这些，对 iOS 编译有个整体认识。就本人而言，在一路搜寻资料的过程中，对之前一些零散的知识点有了一些更加深入的认识。由于篇幅有限，关于 SwiftC 的编译过程没有多做介绍，后面会再出一篇进行介绍。</p><p>🔗：</p><p><a href="https://objccn.io/issue-6-3/">ObjC 中国 - Mach-O 可执行文件</a></p><p><a href="https://kiprey.github.io/2020/06/LLVM-IR-pass/">代码优化与LLVM IR pass</a></p><p><a href="http://xelz.info/blog/2018/11/24/all-you-need-to-know-about-bitcode/">关于bitcode, 知道这些就够了</a></p><p><a href="https://zhuanlan.zhihu.com/p/340782811">iOS 编译链接：Objective-C 编译链接</a></p><p><a href="https://www.jianshu.com/p/54d842db3f69">趣探 Mach-O：文件格式分析</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;学习 &lt;strong&gt;iOS&lt;/strong&gt; 编译过程（&lt;strong&gt;Compile&lt;/strong&gt;）有助于我们更好理解代码是如何被计算机运作起来，编译器为代码做了哪些优化，让我们学会从另一个角度来看待问题。&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://xuhaodong1.github.io/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://xuhaodong1.github.io/tags/iOS/"/>
    
    <category term="Compile" scheme="https://xuhaodong1.github.io/tags/Compile/"/>
    
  </entry>
  
  <entry>
    <title>NSTimer循环引用分析与解决</title>
    <link href="https://xuhaodong1.github.io/2021/09/29/2021-09-29-NSTimer%20%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E5%88%86%E6%9E%90%E4%B8%8E%E8%A7%A3%E5%86%B3/"/>
    <id>https://xuhaodong1.github.io/2021/09/29/2021-09-29-NSTimer%20%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E5%88%86%E6%9E%90%E4%B8%8E%E8%A7%A3%E5%86%B3/</id>
    <published>2021-09-29T14:54:49.000Z</published>
    <updated>2022-12-20T13:01:35.260Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文将从如何使用 <strong>NSTimer</strong> 、 <strong>NSTimer</strong> 何种情况下会造成循环引用，以及如何避免循环引用几个角度进行介绍。</p><span id="more"></span><h3 id="NSTimer-如何使用"><a href="#NSTimer-如何使用" class="headerlink" title="NSTimer 如何使用"></a>NSTimer 如何使用</h3><blockquote><p>A timer that fires after a certain time interval has elapsed, sending a specified message to a target object.</p><p>翻译：一种计时器，在经过一定的时间间隔后触发，向目标对象发送指定的消息。</p></blockquote><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p><strong>NSTimer</strong> 提供了三种创建方式：</p><ol><li><p>以 <code>scheduledTimerWithTimeInterval</code> 类方法开头的创建实例</p></li><li><p>以 <code>timerWithTimeInterval</code> 开头的创建实例</p></li><li><p>以 <code>init</code> 方法初始化方法创建实例</p></li></ol><p>若采用第一种方式创建，会以 <strong>default mode</strong> 方式自动加入到当前的 <strong>RunLoop</strong> 中。</p><p>若采用第二、三种方式创建，需手动调用NSRunLoop对象的 <code>addTimer:forMode:</code> 方法。</p><pre><code class="swift">let timer = Timer.init(timeInterval: 1.0, repeats: true) { timer in   print("This")}RunLoop.main.add(timer, forMode: .default)</code></pre><h4 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h4><p><code>invalidate()</code> </p><p>该方法是在其加入的 <strong>RunLoop</strong> 对象中移除timer的唯一方法，同时会 <strong>RunLoop</strong> 对象会移除其对对象的强引用，若配置了 <strong>target</strong> 和 <strong>user info</strong> 对象， <strong>timer</strong> 也会移除对这些对象的强引用。</p><h3 id="为何会造成循环引用"><a href="#为何会造成循环引用" class="headerlink" title="为何会造成循环引用"></a>为何会造成循环引用</h3><h4 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h4><p>考虑一个常见使用 <strong>NSTimer</strong> 的场景：在 <strong>ViewController</strong> 中将 <strong>timer</strong> 作为属性，而 <strong>timer</strong> 在创建采用了 <strong>target-action</strong> 的方式，根据 <strong>Apple</strong> 文档，<strong>timer</strong> 会对 <strong>target</strong> 产生强引用，这就产生了有向环，导致循环引用，下图是上例对象引用图：</p><img src="/images/blog/image-20210817112104936.png" alt="image-20210817112104936" style="zoom:40%;"><h4 id="RunLoop持有timer"><a href="#RunLoop持有timer" class="headerlink" title="RunLoop持有timer"></a>RunLoop持有timer</h4><p>还是上例的场景，若在 <strong>timer</strong> 创建时不采用 <strong>target-action</strong> ，是不是就可以解决了？</p><p>确实可以解决，但还存在一个问题，由于 <strong>RunLoop</strong> 对象还持有着 <strong>timer</strong> 对象，这时 <strong>ViewController</strong> 能被正常释放，但 <strong>timer</strong> 的引用计数由于不为 <strong>1</strong> ，无法被释放，这种情况只是 <strong>timer</strong> 无法被释放，并不算循环引用范畴，当然若 <strong>RunLoop</strong> 对象被释放了，则这个 <strong>timer</strong> 也会被释放掉。</p><img src="/images/blog/image-20210817145841853.png" alt="image-20210817145841853" style="zoom:40%;"><p>当然此上两种情况都是将 <strong>timer</strong> 的 <code>repeat</code> 参数设置为 <code>true</code> 时，若为 <code>false</code> 则在定时器第一次触发后，会自动失效，即 <strong>RunLoop</strong> 会移除对 <strong>timer</strong> 的强引用， <strong>timer</strong> 也会移除对 <strong>target</strong> 和 <strong>user info</strong> 对象的强引用。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="合适的时机调用-invalidate"><a href="#合适的时机调用-invalidate" class="headerlink" title="合适的时机调用 invalidate()"></a>合适的时机调用 <code>invalidate()</code></h4><p>在上文介绍了<code>invalidate()</code> ， 我们只需要在合适的时机调用 <code>invalidate()</code>即可。</p><p>那么什么是合适的时机呢？</p><ol><li>若清楚知道什么时候 <strong>timer</strong> 不再使用，则应立即调用。</li><li>若不清楚则应破除循环引用，最后在 <strong>ViewController</strong> 的 <code>deinit</code> 中进行调用。</li></ol><h4 id="针对循环引用，需破除有向环"><a href="#针对循环引用，需破除有向环" class="headerlink" title="针对循环引用，需破除有向环"></a>针对循环引用，需破除有向环</h4><ol><li>采用 <code>weak</code> 关键字修饰 <strong>timer</strong> ，但需采用<code>scheduledTimerWithTimeInterval</code> 类方法开头的创建实例，因为这个方法会将 <strong>timer</strong> 加入到 <strong>RunLoop</strong> 对象中，否则由于 <code>weak</code> 修饰， <strong>timer</strong> 会被自动设为<code>nil</code>。</li><li>采用 <code>weak</code> 关键字修饰 <strong>target</strong> 对象，但需在 <strong>block</strong> 中进行使用，原理大概是 <strong>block</strong> 中的 <strong>weakSelf</strong> 相当于一个临时变量，进而阻止了循环引用。</li><li>采用中介者模式，让其他对象承担 <code>target</code> 角色，从而阻止循环引用。</li><li>基于 <strong>NSProxy</strong> 方式，与 <strong>3</strong> 类似，通过其他对象来阻止循环引用，需注意的是 <strong>NSProxy</strong> 无法直接使用。</li><li>也可直接使用 <strong>Apple</strong> 提供的新 <strong>API</strong>：</li></ol><pre><code class="swift">class func scheduledTimer(withTimeInterval interval: TimeInterval, repeats: Bool, block: @escaping (Timer) -&gt; Void) -&gt; Timerinit(timeInterval interval: TimeInterval, repeats: Bool, block: @escaping (Timer) -&gt; Void)convenience init(fire date: Date, interval: TimeInterval, repeats: Bool, block: @escaping (Timer) -&gt; Void)</code></pre><blockquote><p>the timer itself is passed as the parameter to this block when executed to aid in avoiding cyclical references。</p><p>翻译：在执行时，定时器本身作为参数传递给这个块，以帮助避免循环引用。</p></blockquote><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><a href="https://juejin.cn/post/6844903968250789896#heading-5">iOS之NSTimer循环引用的解决方案</a></p><p><a href="https://www.jianshu.com/p/e8fc6c2b3afa">iOS中Timer循环引用原因及解决方案</a></p><p><a href="https://developer.apple.com/documentation/foundation/nstimer/">Apple文档 - NSTimer</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;本文将从如何使用 &lt;strong&gt;NSTimer&lt;/strong&gt; 、 &lt;strong&gt;NSTimer&lt;/strong&gt; 何种情况下会造成循环引用，以及如何避免循环引用几个角度进行介绍。&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://xuhaodong1.github.io/categories/iOS/"/>
    
    
    <category term="NSTimer" scheme="https://xuhaodong1.github.io/tags/NSTimer/"/>
    
    <category term="iOS" scheme="https://xuhaodong1.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>不以功利为目的</title>
    <link href="https://xuhaodong1.github.io/2021/08/29/2021-11-9-%E4%B8%8D%E4%BB%A5%E5%8A%9F%E5%88%A9%E4%B8%BA%E7%9B%AE%E7%9A%84/"/>
    <id>https://xuhaodong1.github.io/2021/08/29/2021-11-9-%E4%B8%8D%E4%BB%A5%E5%8A%9F%E5%88%A9%E4%B8%BA%E7%9B%AE%E7%9A%84/</id>
    <published>2021-08-29T14:54:49.000Z</published>
    <updated>2023-06-22T15:21:22.568Z</updated>
    
    <content type="html"><![CDATA[<p>今天突然心血来潮想写点什么，本来看着《计算机网络 - 自顶向下方法》。突然觉得我为什么要看本书，这就让我不断的反问，不断的刨根，我是为了面试、为了系统的学习、为了向其他人展示什么…，最终我想到了，我在买这本书的时候，我仅是为了给大学的自己补一下遗憾，没有读几本经典的书，没有去系统的学习一些知识，没有探索计算机那令人叹为观止的地方。回想大学时代，自己从没想过会去完完整整的读一本书。就如“重构”一般，知道它重要，但从未有“恰当”的时间进行下去，抑或是针对其中重要的部分，进行“熟读与背诵”，抑或是直接拿队友的重点笔记进行查阅，但我从没完整的读过一本书。</p><span id="more"></span><p>我在想为什么会这样，我认识到我读书是为什么，是为了考一个好高中、考一个好大学、找一份好工作，还是能够领略一番书中的绮丽瑰宝，可能也只是无聊打发时间罢了。但我想，不应以功利的心态去读书了，那样太累、又太机械，我总想立即从书中获取什么，仿佛有价值千金的宝藏般，让我马上超越其他人。可事实哪有那么容易，每一个人不都是日积月累，有量变引起质变才获得成功的吗。</p><p>毕业以来大概5个月了，我常常在想，我今后会成为怎样的人，我如何才能像其他人一样优秀，可以侃侃而谈，可以谈笑风生。但我想先成为那个一直都想成为的人，做好自己、不断努力、那个随性但又坚定的那个人。我想说很多话，但总觉得人微言轻，所以在我没法掂量轻重时，还是少一些言语，多一分实干。</p><p>最后，从高考作文之后，边再也没有能够抒发情感或是记录生活的地方了，给自己立一个目标，能够以半年或者每个季度或者每个月都能够写一些东西总结下自己的生活，下一步该怎么走，自己有哪些不足。</p><p>最后的最后，不以功利为目的，我想去多看、多想。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天突然心血来潮想写点什么，本来看着《计算机网络 - 自顶向下方法》。突然觉得我为什么要看本书，这就让我不断的反问，不断的刨根，我是为了面试、为了系统的学习、为了向其他人展示什么…，最终我想到了，我在买这本书的时候，我仅是为了给大学的自己补一下遗憾，没有读几本经典的书，没有去系统的学习一些知识，没有探索计算机那令人叹为观止的地方。回想大学时代，自己从没想过会去完完整整的读一本书。就如“重构”一般，知道它重要，但从未有“恰当”的时间进行下去，抑或是针对其中重要的部分，进行“熟读与背诵”，抑或是直接拿队友的重点笔记进行查阅，但我从没完整的读过一本书。&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://xuhaodong1.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="https://xuhaodong1.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
